### 课程介绍

+ 手机网站

  ​	定高法 （宽度自适应 高度写死）
  ​	rem  （宽高完全自适应）
  ​	学习核心：自适应布局 + touch事件的运用+rem

+ 一站式网站
  + 从手机到pc一站式兼容
  + 学习核心：bootstrap的运用

### 移动网站的分类

- 原生app（native app）
- 混合app（Hybrid app）
- web应用（webApp）

**原生app（native app）**

原生app是基于操作系统的开发，比如安卓，ios，windows phone,他们只能在各自的操作系统上运行。

优点：

1. 可以访问操作系统，获取更多的资源（gps，摄像头，传感器，麦克风等）
2. 速度快，性能高，用户体验好
3. 可以离线使用

缺点：

1. 开发成本高
2. 需要安装和更新，更新与发布需要审核。

**混合app（Hybrid app）**

使用H5C3开发页面，打包成不同平台的应用（ipa，apk等）

优点：

1. 更新更加方便
2. 开发成本更低，兼容多个平台
3. 也可以访问手机的操作系统资源。

缺点：

1. 用户体验相比原生app稍差。
2. 性能依赖于网速

**Web App**

Web应用使用H5C3开发页面，为浏览器设计的基于web的应用，可以在各种智能设备的手机浏览器上运行。

优点：

1. 支持设备广泛
2. 开发成本低
3. 可以随时上线与更新，无需审核

缺点：

1. 用户体验极度依赖网速
2. 要求联网
3. 没有办法获取资源

总结：

三种开发各有优缺点，具体用什么需要根据实际情况而定，比如预算，app注重功能还是内容等。

![](image/移动开发分类.png)

### 流式布局

流式布局其实就是百分比布局，是移动web开发使用的常用布局方式之一

**移动端的特点**

- 手机端的兼容性问题比PC端小很多，因为手机端的浏览器版本比较新
- 手机端屏幕比较小，能够放的内容比较少。

问题：布局的时候怎么解决屏幕大小不一致的问题？

- PC端，固定版心，让所有分辨率的电脑的版心都是一样的，比如京东
- 移动端：移动端无法设置版心，因为移动端的设备屏幕本身就小，设置版心不合适。因此移动端大多会采用流式布局（百分比布局）

  **流式布局下的几个页面特征（定高法）**

   -  宽度自适应，高度写死（最小屏幕的高度），不能百分百去还原设计图

   -  一些小ICON 图标等都是写死的 不是所有的东西都是自适应的，一般都是模块会呈现自适应

   -  一些产品插入图 也就是img等都默认设置宽度百分百，让其自动保持等比例缩放，一般不予写死

   -  字体大小等都是写死的（后期可以使用媒体查询来改变字体大小）

  后期会学到rem结合流式布局的写法：使用rem去计算高度，百分比去计算宽度，实现宽高完全自适应。

#### 移动端的几个经典页面布局

+ 左侧固定 右侧自适应
+ 两侧固定 中间自适应
+ 中间固定 两边自适应
+ 等分布局

### 手机模拟器

​	手机设备五花八门，并且每个尺寸都不太一样，所以给我们的预览带来了一些麻烦，在实际工作中，作为开发者不可能给你足够多的设备让你去测试（一般是专门的测试部门才有），即使有那效率也会特别低，所以开发者都是借助于手机模拟器去模拟不同的手机来测试

​	步骤：谷歌浏览器里面按F12，选择小手机图标点击一下会切换到手机模式

![wps4974.tmp](C:\Users\Administrator\Desktop\上海十六期\移动web第一天\01-教学资料\笔记\image\wps4974.tmp.jpg)

​	![wps4974.tmp](C:\Users\Administrator\Desktop\上海十六期\移动web第一天\01-教学资料\笔记\image\wps4985.tmp.jpg)

### 视口 Viewport（重要）

猜想：

1. pc页面在移动设备上显示情况。

   答案：

现象说明：

在pc端，html的大小由浏览器决定，但是在手机端，中间还加了一个视口作为中间层，视口默认的大小就是980（视口在出现的时候，主流版心是980）同时视口默认会收缩到当前手机屏幕的大小（连同里面包裹的页面）	

视口设置：

早期视口能够让页面在手机上也能直接浏览，但是体验不好，（默认缩小看不清，手指放大看不全），所以后期迎来了另外一种开发模式

视口就和手机的屏幕一样大，不允许视口去缩放，同时不允许用户缩放，就针对手机去做专门的设计图，针对不同大小的手机采用自适应技术完成

视口的参数

~~~javascript
width：宽度设置的是viewport宽度，可以设置device-width特殊值

initial-scale：初始缩放比，大于0的数字（缩放是基于屏幕来的）

user-scalable：用户是否可以缩放，yes或no（1或0）

maximum-scale：最大缩放比，大于0的数字

minimum-scale：最小缩放比，大于0的数字

标准写法：

快捷键：meta:vp + tab 自动生成

<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
~~~

## 屏幕与分辨率

> 移动设备与PC设备最大的差异在于屏幕，这主要体现在屏幕尺寸和屏幕分辨率两个方面。

### 屏幕尺寸

通常我们所指的屏幕`尺寸`，实际上指的是屏幕对角线的长度（一般用英寸来度量）如下图所示

![屏幕尺寸](C:\Users\Administrator\Desktop\上海十六期\移动web第一天\01-教学资料\笔记\image\屏幕尺寸.png)

### 屏幕分辨率

分辨率则一般用像素来度量，表示屏幕水平和垂直方向的像素数，例如1920*1080指的是屏幕垂直方向和水平方向分别有1920和1080个像素点而构成，如下图所示,分辨率越高，越清晰。

`像素`：指计算机显示设备中的最小单位，即一个像素点的大小。

像素是相对长度单位，在屏幕分辨率越高的设备，像素点越小，屏幕分辨率越低，像素点越大。

![](image/ppi对比.png)

### 像素密度ppi(了解)

`PPI（Pixels Per Inch）`值来表示屏幕每英寸的像素数

利用 *勾股定理* 我们可以计算得出PPI

PPI值的越大说明单位尺寸里所能容纳的像素数量就越多，所能展现画面的品质也就越精细，反之就越粗糙。

**结论：当PPI 越大，展示的画质越精细。**

## 设备独立像素

> 随着技术发展，设备不断更新，出现了不同PPI的屏幕共存的状态,给我们开发带来的很大的难题

做为用户是不会关心这些细节的，他们只是希望在不同PPI的设备上看到的图像内容差不多大小，所以这时我们需要一个新的单位，`这个新的单位能够保证图像内容在不同的PPI设备看上去大小应该差不多`，这就是独立像素,也叫（设备无关像素），在IOS设备上叫`PT`，Android设备上叫`DP`，在css中，叫`PX`。

获取设备的像素比

```javascript
window.devicePixelRatio  //物理像素与独立像素的比值
```

## ![](image/2x.png)

把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度。

![jd_4](C:\Users\Administrator\Desktop\上海十六期\移动web第一天\01-教学资料\笔记\image\jd_4.png)

### touch事件

```
（1）touchstart：当手指触碰屏幕时候发生。不管当前有多少只手指

（2）touchmove：当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，

会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动

（3）touchend：当手指离开屏幕时触发

（4）touchcancel：系统停止跟踪触摸时候会触发。

例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用

```

**触摸事件的响应顺序**

1、ontouchstart

2、ontouchmove

3、ontouchend

4、onclick  300ms延时

触摸列表

```
targetTouches 目标元素的所有当前触摸 
changedTouches 页面上最新更改的所有触摸，在touchend里面触发，只有touchend的才可以获取event手指坐标
touches 页面上的所有触摸
```

**注意：在touchend事件的时候event只会记录changedtouches**

**touch的手指位置**

```
clientX、clientY 相对于当前屏幕的X或Y位置

pageX、pageY 相对于整体页面的X或Y位置 

screenX、screenY 相对于用户计算机屏幕的X或Y位置

```

**轮播图思路**

	 css 准备工作
	 （1）核心 是将所有的li元素用定位去实现
	 （2）因为所有的li定位了，所以ul设置一个最小高，后期到JS里面动态去求
	 （3）创建小圆点的样式（让一个位置的宽度盒子水平居中 两种方法：利用transform：transalteX（-50%）或者利用行内块配合父容器的text-align：center去控制）
	 （4）让所有的li都到屏幕外面去
	 （5）移动元素的时候不要用left去移动，用transform去移动，这样不会改变原点（说白了，给这个元素加个transform：translateX（0px）就可以回到原点）
	
	 JS准备工作
	 （1）动态设置ul的高度
	 （2）动态创建小圆点
	
	 自动轮播的逻辑
	 （1）设置三个基本的位置变量 将三个基本下标赋值
	 （2）三个基本下标：最后一个li的下标  0 1
	 （3）执行归位操作
	 （4）开启定时器，轮转下标，极值判断，添加过渡，执行归位 ，设置原点