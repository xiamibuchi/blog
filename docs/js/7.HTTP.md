# HTTP

## 基础

HTTP 协议是 HyperText Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。
HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。
HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。

超文本传输协议，是一个基于请求与响应，无状态的，是一个基于 TCP/IP 实现的应用层协议

TCP: Transmission Control Protocol 传输控制协议，负责应用软件（比如你的浏览器）和网络软件之间的通信
IP: Internet Protocol 网际协议，计算机用来相互识别的通信的一种机制

1. 支持客户/服务器模式。(C/S 客户端-服务器,B/S 浏览器-服务器)
2. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
3. 灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
4. 无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

> 注：HTTP 的默认端口号为 80，HTTPS 的默认端口号为 443。

| **版本** | **产生时间** | **内容**                                                                                                                                                                        | **发展现状**        |
| -------- | ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- |
| HTTP/0.9 | 1991 年      | 不涉及数据包传输，规定客户端和服务器之间通信格式，只能 GET 请求                                                                                                                 | 没有作为正式的标准  |
| HTTP/1.0 | 1996 年      | 传输内容格式不限制，增加 PUT、PATCH、HEAD、 OPTIONS、DELETE 命令                                                                                                                | 正式作为标准        |
| HTTP/1.1 | 1997 年      | 持久连接(长连接)、节约带宽、HOST 域、管道机制、分块传输编码                                                                                                                     | 2015 年前使用最广泛 |
| HTTP/2   | 2015 年      | 多路复用（通过单一的 HTTP/2 连接请求发起多重的请求-响应消息，多个请求 stream 共享一个 TCP 连接，实现多留并行而不是依赖建立多个 TCP 连接）、服务器推送、头信息压缩、二进制协议等 | 逐渐覆盖市场        |

请求：

```text
请求方法 URL HTTP/版本号
请求首部字段(可选)
空行
body
```

响应：

```text
HTTP/版本号 返回码 返回码描述
应答首部字段(可选)
空行
body
```

### URL

使用 HTTP 协议访问资源是通过 URL（Uniform Resource Locator）统一资源定位符来实现的。URL 的格式如下：

```text
scheme://host:port/path?query

scheme: 表示协议，如Http, Https, Ftp等；
host: 表示所访问资源所在的主机名：如：www.abc.com;
port: 表示端口号，默认为80；
path: 表示所访问的资源在目标主机上的储存路径；
query: 表示查询条件；

例如： http://www.abc.com/search?words=abc
```

`统一资源标识符`(uniform resource identifier URI)

URI 是个纯粹的句法结构，用于指定标识 Web 资源的字符串的各个不同部分。URL 是 URI 的一个特例，它包含了定位 Web 资源的足够信息。

**URI 是统一资源标识符，而 URL 是统一资源定位符。**因此，笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。

**URI—Uniform Resource Identifier 通用资源标志符**Web 上可用的每种资源如 HTML 文档、图像、视频片段、程序等都是一个来 URI 来定位的
URI 一般由三部组成
① 访问资源的命名机制
② 存放资源的主机名
③ 资源自身的名称，由路径表示，着重强调于资源。

**URL—Uniform Resource Location 统一资源定位符**URL 是 Internet 上用来描述信息资源的字符串，主要用在各种 WWW 客户程序和服务器程序上，特别是著名的 Mosaic。
采用 URL 可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。
URL 一般由三部组成
① 协议(或称为服务方式)
② 存有该资源的主机 IP 地址(有时也包括端口号)
③ 主机资源的具体地址。如目录和文件名等

HTTP 请求的内容通称为"资源"。”资源“这一概念非常宽泛，它可以是一份文档，一张图片，或所有其他你能够想到的格式。每个资源都由一个 ([URI](https://developer.mozilla.org/en-US/docs/Glossary/URI)) 来进行标识。

一般情况下，资源的名称和位置由同一个 URL（统一资源定位符，它是 URI 的一种）来标识。也有某些特殊情况，资源的名称和位置由不同的 URI 进行标识：例如，待请求的资源希望客户端从另外一个位置访问它。我们可以使用一个特定的首部字段，[`Alt-Svc`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Alt-Svc)，来指示这种情况。

统一资源标志符 URI 就是在某一规则下能把一个资源独一无二地标识出来。
拿人做例子，假设这个世界上所有人的名字都不能重复，那么名字就是 URI 的一个实例，通过名字这个字符串就可以标识出唯一的一个人。
现实当中名字当然是会重复的，所以身份证号才是 URI，通过身份证号能让我们能且仅能确定一个人。
那统一资源定位符 URL 是什么呢。也拿人做例子然后跟 HTTP 的 URL 做类比，就可以有：

动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14 号宿舍楼/525 号寝/张三.人

可以看到，这个字符串同样标识出了唯一的一个人，起到了 URI 的作用，所以 URL 是 URI 的子集。URL 是以描述人的位置来唯一确定一个人的。
在上文我们用身份证号也可以唯一确定一个人。对于这个在杭州的张三，我们也可以用：

身份证号：[123456789](tel:123456789)

来标识他。
所以不论是用定位的方式还是用编号的方式，我们都可以唯一确定一个人，都是 URl 的一种实现，而 URL 就是用定位的方式实现的 URI。

http://741236985.html**

### 报文字段

HTTP 的报文字段分为 5 种：

- 请求报文字段
- 应答报文字段
- 实体首部字段
- 通用报文字段
- 其他报文字段

#### 请求报文字段

HTTP 请求中支持的报文字段。

```text
Accept：客户端能够处理的媒体类型。如text/html, 表示客户端让服务器返回html类型的数据，如果没有，返回text
类型的也可以。媒体类型的格式一般为：type/subType, 表示优先请求subType类型的数据，如果没有，返回type类型
数据也可以。

常见的媒体类型：
文本文件：text/html, text/plain, text/css, application/xml
图片文件：iamge/jpeg, image/gif, image/png;
视频文件：video/mpeg
应用程序使用的二进制文件：application/octet-stream, application/zip

Accept字段可设置多个字段值，这样服务器依次进行匹配，并返回最先匹配到的媒体类型，当然，也可通过q参数来设置
媒体类型的权重，权重越高，优先级越高。q的取值为[0, 1], 可取小数点后3位，默认为1.0。例如：
Accept: text/html, application/xml; q=0.9, */*

Accept-Charset: 表示客户端支持的字符集。例如：Accept-Charset: GB2312, ISO-8859-1

Accept-Encoding： 表示客户端支持的内容编码格式。如：Accept-Encoding：gzip

常用的内容编码：
gzip: 由文件压缩程序gzip生成的编码格式；
compress: 由Unix文件压缩程序compress生成的编码格式；
deflate: 组合使用zlib和deflate压缩算法生成的编码格式；
identity：默认的编码格式，不执行压缩。

Accept-Language：表示客户端支持的语言。如：Accept-Language: zh-cn, en

Authorization：表示客户端的认证信息。客户端在访问需要认证的也是时，服务器会返回401，随后客户端将认证信息
加在Authorization字段中发送到服务器后，如果认证成功，则返回200. 如Linux公社下的Ftp服务器就是这种流程：
ftp://ftp1.linuxidc.com。

Host: 表示访问资源所在的主机名，即URL中的域名部分。如：m.baidu.com

If-Match: If-Match的值与所请求资源的ETag值（实体标记，与资源相关联。资源变化，实体标记跟着变化）一致时，
服务器才处理此请求。

If-Modified-Since: 用于确认客户端拥有的本地资源的时效性。 如果客户端请求的资源在If-Modified-Since指定
的时间后发生了改变，则服务器处理该请求。如：If-Modified-Since:Thu 09 Jul 2018 00:00:00, 表示如果客户
端请求的资源在2018年1月9号0点之后发生了变化，则服务器处理改请求。通过该字段我们可解决以下问题：有一个包含大
量数据的接口，且实时性较高，我们在刷新时就可使用改字段，从而避免多余的流量消耗。

If-None-Match: If-Match的值与所请求资源的ETag值不一致时服务器才处理此请求。

If-Range： If-Range的值（ETag值或时间）与所访问资源的ETag值或时间相一致时，服务器处理此请求，并返回
Range字段中设置的指定范围的数据。如果不一致，则返回所有内容。If-Range其实算是If-Match的升级版，因为它
的值不匹配时，依然能够返回数据，而If-Match不匹配时，请求不会被处理，需要数据时需再次进行请求。


If-Unmodified-Since：与If-Modified-Since相反，表示请求的资源在指定的时间之后未发生变化时，才处理请求，
否则返回412。

Max-Forwards：表示请求可经过的服务器的最大数目，请求每被转发一次，Max-Forwards减1，当Max-Forwards为0
时，所在的服务器将不再转发，而是直接做出应答。通过此字段可定位通信问题，比如之前支付宝光纤被挖断，就可通过设
置Max-Forwards来定位大概的位置。

Proxy-Authorization：当客户端接收到来自代理服务器的认证质询时，客户端会将认证信息添加到
Proxy-Authorization来完成认证。与Authorization类似，只不过Authorization是发生在客户端与服务端之间。

Range：获取部分资源，例如：Range: bytes=500-1000表示获取指定资源的第500到1000字节之间的内容，如果服务器
能够正确处理，则返回206作为应答，表示返回了部分数据，如果不能处理这种范围请求，则以200作为应答，返回完整的
数据，

Referer：告知服务器请求是从哪个页面发起的。例如在百度首页中搜索某个关键字，结果页面的请求头部就会有这个字段，
其值为https://www.baidu.com/。通过这个字段可统计广告的点击情况。

User-Agent：将发起请求的浏览器和代理名称等信息发送给服务端，例如：
User-Agent: Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36
(KHTML, like Gecko) Chrome/63.0.3239.84 Mobile Safari/537.36
复制代码
```

#### 应答报文字段

HTTP 应答中支持的报文字段。

```text
表示不能处理。

Age：服务端告知客户端，源服务器（而不是缓存服务器）在多久之前创建了响应。
单位为秒。

ETag： 实体资源的标识，可用来请求指定的资源。

Location：请求的资源所在的新位置。

Proxy-Authenticate：将代理服务器需要的认证信息发送给客户端。

Retry-After：服务端告知客户端多久之后再重试，一般与503和3xx重定向类型的应答一起使用。

Server：告知服务端当前使用的HTTP服务器应用程序的相关信息。

WWW-Authenticate：告知客户端适用于所访问资源的认证方案，如Basic或Digest。401的响应中肯定带有
WWW-Authenticate字段。
复制代码
```

#### 实体首部字段

```text
Allow：通知客户端，服务器所支持的请求方法。但服务器收到不支持的请求方法时，会以405（Method Not Allowed）
作为响应。

Content-Encoding：告知客户端，服务器对资源的内容编码。

Content-Language：告知客户端，资源所使用的自然语言。

Content-Length：告知客户端资源的长度

Content-Location：告知客户端资源所在的位置。

Content-Type：告知客户端资源的媒体类型，取值同请求首部字段中的Accept。

Expires：告知客户端资源的失效日期。可用于对缓存的处理。

Last-Modified：告知客户端资源最后一次修改的时间。
复制代码
```

#### 通用报文字段

即可在 HTTP 请求中使用，也可在 HTTP 应答中使用的报文字段。

```text
Cache-Control：控制缓存行为；

Connection：管理持久连接，设置其值为Keep-Alive可实现长连接。

Date：创建HTTP报文的日期和时间。

Pragma：Http/1.1之前的历史遗留字段，仅作为HTTP/1.0向后兼容而定义，虽然是通用字段，当通常被使用在客户单的
请求中，如Pragma: no-cache, 表示客户端在请求过程中不循序服务端返回缓存的数据；

Transfer-Encoding：规定了传输报文主题时使用的传输编码，如Transfer-Encoding: chunked

Upgrade: 用于检查HTTP协议或其他协议是否有可使用的更高版本。

Via：追踪客户端和服务端之间的报文的传输路径，还可避免会环的发生，所以在经过代理时必须添加此字段。

Warning：Http/1.1的报文字段，从Http/1.0的AfterRetry演变而来，用来告知用户一些与缓存相关的警告信息。
复制代码
```

#### 其他报文字段

这些字段不是 HTTP 协议中定义的，但被广泛应用于 HTTP 请求中。

- Cookie：属于请求型报文字段，在请求时添加 Cookie, 以实现 HTTP 的状态记录。
- Set-Cookie：属于应答型报文字段。服务器给客户端传递 Cookie 信息时，就是通过此字段实现的。

Set-Cookie 的字段属性：

```text
NAME=VALUE：赋予Cookie的名称和值；
expires=DATE: Cookie的有效期；
path=PATH: 将服务器上的目录作为Cookie的适用对象，若不指定，则默认为文档所在的文件目录；
domin=域名：作为Cookies适用对象的域名，若不指定，则默认为创建Cookie的服务器域名；
Secure: 仅在HTTPS安全通信是才会发送Cookie；
HttpOnly: 使Cookie不能被JS脚本访问；

如：Set-Cookie:BDSVRBFE=Go; max-age=10; domain=m.baidu.com; path=/
```

### 特点

- 无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作
- 无连接：HTTP/1.1 之前，由于无状态特点，每次请求需要通过 TCP 三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。
- 基于请求和响应：基本的特性，由客户端发起请求，服务端响应
- 简单快速、灵活
- 通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性

### 缺点

- 通信使用明文，可能被窃听
- 不验证通信方的身份，可能遭遇伪装
- 无法证明报文的完整性，有可能遭遇篡改

## TCP/IP 协议

### 三次握手

首先，客户端与服务器均处于未连接状态，并且是客户端主动向服务器请求建立连接：

客户端将报文段中的 SYN=1，并选择一个 seq=x，(即该请求报文的序号为 x) 将这个报文发送到服务器。此时，客户端进入同步已发送状态（SYN-SEND）.SYN 报文段不能携带数据，但是要消耗掉一个序号。
服务器收到请求报文后，若同意建立连接，则回复报文中，SYN=1,ACK=1，并选择一个 seq = y,且报文中确认号为 x+1，序号为 y .此时服务器进入同步已接收状态（SYN-RCVD）

客户端收到服务器的同步确认后，对服务器发送确认的确认。将 ACK=1,确认号为 y+1,而报文首部的序号为 x+1，将该报文发出后，客户端进入已连接状态（ESTABLISHED）。

服务器收到客户端的确认后，也进入已连接状态。即三次握手

### 四次挥手

连接的释放较连接的建立复杂。

现假设客户端与服务器均处于连接建立状态，客户端主动断开连接：

1. 客户端向服务器发送 FIN 报文：FIN=1,序号 seq=上一个最后传输的字节序号+1=u，发送后，客户端进入 FIN-WAIT-1 状态。
2. 服务器接收到该报文后，发送一个确认报文：令 ACK=1，确认序号 ack = u+1,自己的报文序号 seq=v，发送后，服务器进入 CLOSE-WAIT 状态。
3. 此时 TCP 连接进入连接半关闭状态，服务器可能还会向客户端发送一些数据。
4. 客户端收到来自服务器的确认之后，进入 FIN-WAIT-2 状态。等待服务器发送连接释放报文。
5. 如果服务器已经没有要发送的数据，则释放 TCP 连接，向客户端发送报文：令 FIN=1，ACK=1,确认号 ack =u+1，自己的序号 seq = w（w 可能等于 v 也可能大于 v），服务器进入 LAST-ACK 状态。
6. 客户端收到服务器的连接释放报文后，对该报文发出确认，令 ACK=1,确认号 ack=w+1，自己的序号 seq=u+1，发送此报文后，等待 2 个 msl 时间后，进入 CLOSED 状态。
7. 服务器收到客户端的确认后，也进入 CLOSED 状态并撤销传输控制块。

客户端状态变化：未连接----->SYN-SEND----->ESTABLISHED----->FIN-WAIT-1----->FIN-WAIT-2----->TIME-WAIT----->CLOSED

服务器状态变化：未连接----->SYN-RCVD----->ESTABLISHED----->CLOSE-WAIT----->LAST-ACK----->CLOSED

通俗描述 3 次握手就是：

A 对 B 说：我的序号是 x，我要向你请求连接；（第一次握手，发送 SYN 包，然后进入 SYN-SEND 状态）

B 听到之后对 A 说：我的序号是 y，期待你下一句序号是 x+1 的话（意思就是收到了序号为 x 的话，即 ack=x+1），同意建立连接。（第二次握手，发送 ACK-SYN 包，然后进入 SYN-RCVD 状态）

A 听到 B 说同意建立连接之后，对 A 说：与确认你同意与我连接（ack=y+1,ACK=1,seq=x+1）。（第三次握手，A 已进入 ESTABLISHED 状态）

B 听到 A 的确认之后，也进入 ESTABLISHED 状态。

描述四次挥手就是：

1.A 与 B 交谈结束之后，A 要结束此次会话，对 B 说：我要关闭连接了（seq=u,FIN=1）。（第一次挥手，A 进入 FIN-WAIT-1）

2.B 收到 A 的消息后说：确认，你要关闭连接了。（seq=v,ack=u+1,ACK=1）（第二次挥手，B 进入 CLOSE-WAIT）

3.A 收到 B 的确认后,等了一段时间，因为 B 可能还有话要对他说。（此时 A 进入 FIN-WAIT-2）

4.B 说完了他要说的话（只是可能还有话说）之后，对 A 说，我要关闭连接了。（seq=w, ack=u+1,FIN=1，ACK=1）(第三次挥手)
5.A 收到 B 要结束连接的消息后说：已收到你要关闭连接的消息。（seq=u+1,ack=w+1,ACK=1）(第四次挥手，然后 A 进入 CLOSED)
6.B 收到 A 的确认后，也进入 CLOSED。

## HTTPS

HTTP 是明文传输的，这就意味着介于发送端和接收端之间的任意节点都可以知道传输的内容是什么，这些节点可以是路由器、代理等

HTTPS，经由 HTTP 进行通信，利用 SSL/TLS 建立全信道，加密数据包。HTTPS 比 HTTP 多了一层 TLS/SSL 协议

TLS（传输层安全）跟 SSL（安全套接字）可以理解成类似的东西，可以将 SSL 理解成负责对 HTTP 的数据进行加密的加密套件，而 TLS 是 SSL 的升级版/继任者。

TLS 的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥， 然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。

### 身份验证 CA 和证书

解决身份验证问题的关键是确保获取的公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构 CA(如沃通 CA)。CA 负责核实公钥的拥有者的信息，并颁发认证"证书"，同时能够为使用者提供证书验证服务，即 PKI 体系(PKI 基础知识)。
基本的原理为，CA 负责审核信息，然后对关键信息利用私钥进行"签名"，公开对应的公钥，客户端可以利用公钥验证签名。

### 特点

- 内容加密：采用混合加密技术，中间者无法直接查看明文内容
- 验证身份：通过证书认证客户端访问的是自己的服务器
- 保护数据完整性：防止传输的内容被中间人冒充或者篡改

**混合加密：**结合非对称加密和对称加密技术。客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，所以网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘密秘钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的秘钥，便无法获取到明文数据。

**数字摘要：**通过单向 hash 函数对原文进行哈希，将需加密的明文“摘要”成一串固定长度(如 128bit)的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文。

**数字签名技术：**数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥加密技术和数字摘要结合起来，形成了实用的数字签名技术。

> 非对称加密过程需要用到公钥进行加密，那么公钥从何而来？其实公钥就被包含在数字证书中，数字证书通常来说是由受信任的数字证书颁发机构 CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。

### 缺点

- SSL 证书需要购买申请，功能越强大的证书费用越高
- SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗（SSL 有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP 就不支持这个扩展，考虑到 XP 的装机量，这个特性几乎没用）。
- 根据 ACM CoNEXT 数据显示，使用 HTTPS 协议会使页面的加载时间延长近 50%，增加 10%到 20%的耗电。
- HTTPS 连接缓存不如 HTTP 高效，流量成本高。
- HTTPS 连接服务器端资源占用高很多，支持访客多的网站需要投入更大的成本。
- HTTPS 协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方式是采用分而治之，类似 12306 网站的主页使用 HTTP 协议，有关于用户信息等方面使用 HTTPS。

## ajax

Asynchronous [e'sɪŋkrənəs] Javascript And XML， AJAX 不是一门的新的语言，而是对现有技术的综合利用。 本质是在 HTTP 协议的基础上以异步的方式与服务器进行通信。

### XMLHttpRequest 对象

浏览器内建对象，用于与服务器通信(交换数据)

### GET 和 POST 请求的区别

1. HTTP 没有要求，如果 Method 是 POST 数据就要放在 BODY 中。也没有要求，如果 Method 是 GET，数据（参数）就一定要放在 URL 中而不能放在 BODY 中。但在浏览器中，GET 提交的数据会放在 URL 之后，POST 是把提交的数据放在 HTTP 消息的 Body 中
2. HTTP 协议从未规定过 GET/POST 请求长度是多少，GET 提交的数据大小有限制是某些浏览器或服务器对 URL 的长度有限制，而 POST 方法提交的数据没有限制
3. 多数浏览器对于 POST 采用两阶段发送数据的
4. GET 方式请求的数据会被浏览器缓存起来
5. GET 幂等，而 POST 请求不是

> 幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一 URL 的多个请求应该返回同样的结果。

### 跨域

浏览器的同源策略限制，浏览器会拒绝跨域请求

#### 简单请求和非简单请求

简单请求：使用下列方法之一且没有人为设置对 CORS 安全的首部字段集合之外的其他首部字段：

```text
GET
HEAD
POST- 仅当POST方法的Content-Type值等于下列之一才算作简单请求
 - text/plain
 - multipart/form-data
 - application/x-www-form-urlencoded
```

#### JSONP

利用资源请求标签（script）可引入不同域上的 js 脚本，在 js 文件载入完毕之后，触发回调

优点：兼容性好（兼容低版本 IE）
缺点：1.JSONP 只支持 GET 请求； 2.错误处理机制缺失

#### CORS

```text
Access-Control-Allow-Origin: foo.example    // 标识可接受的跨域请求源；  Access-Control-Allow-Methods: POST, GET, OPTIONS   //标识可接受的跨域请求方法,如GET、POST、OPTIONS；  Access-Control-Allow-Headers: X-PINGOTHER, Content-Type //标识可接受的跨域请求自定义头；  Access-Control-Max-Age: 86400。 //标识本次预请求的有效时间（秒），期间内无需再发送预请求；
```

#### postMessage

window.postMessage(message,targetOrigin) 方法是 html5 新引进的特性，可以使用它来向其它的 window 对象发送消息

```js
var channel = new MessageChannel();
var output = document.querySelector(".output");
var iframe = document.querySelector("iframe");

// Wait for the iframe to load
iframe.addEventListener("load", onLoad);

function onLoad() {
  // Listen for messages on port1
  channel.port1.onmessage = onMessage;

  // Transfer port2 to the iframe
  iframe.contentWindow.postMessage("Hello from the main page!", "*", [
    channel.port2
  ]);
}

// Handle messages received on port1
function onMessage(e) {
  output.innerHTML = e.data;
}
```

## fetch

```javascript
fetch(url, options).then(
  function(response) {
    // handle HTTP response
  },
  function(error) {
    // handle network error
  }
);
```

说明：

1. fetch api 返回的是一个 promise 对象
2. Options:
   - method(String): HTTP 请求方法，默认为 GET
   - body(String): HTTP 的请求参数
   - headers(Object): HTTP 的请求头，默认为{}
   - credentials(String): 默认为 omit,忽略的意思，也就是不带 cookie;还有两个参数，same-origin，意思就是同源请求带 cookie；include,表示无论跨域还是同源请求都会带 cookie
3. 第一个 then 函数里面处理的是 response 的格式
   - status(number): HTTP 返回的状态码，范围在 100-599 之间
     statusText(String): 服务器返回的状态文字描述，例如 Unauthorized,上图中返回的是 Ok
     ok(Boolean): 如果状态码是以 2 开头的，则为 true
     headers: HTTP 请求返回头
     body: 返回体，这里有处理返回体的一些方法
     text(): 将返回体处理成字符串类型
     json()： 返回结果和 JSON.parse(responseText)一样
     blob()： 返回一个 Blob，Blob 对象是一个不可更改的类文件的二进制数据
     arrayBuffer()
     formData()

### 问题

1. 兼容性
   IE 浏览器完全不支持 fetch，移动端的很多浏览器也不支持,所以，如果要在这些浏览器上使用 Fetch，就必须使用 fetch polyfill
2. cookie 传递
   必须在 header 参数里面加上 credientials: 'include'，才会如 xhr 一样将当前 cookies 带到请求中去
3. fetch 和 xhr 的不同
   fetch 虽然底层，但是还是缺少一些常用 xhr 有的方法，比如能够取消请求（abort）方法。fetch 在服务器返回 4xx、5xx 时是不会抛出错误的，这里需要手动通过，通过 response 中的 ok 字段和 status 字段来判断

## JSON

JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript 规范，采用独立于编程语言的文本格式来存储和表示数据。

特点：

- 数据在 键值对 中
- 数据由逗号分隔(最后一个 键值对 不能带逗号)
- 花括号保存对象，方括号保存数组
- 键使用双引号
- JSON 内部常用数据类型无非就是字符串、数字、布尔、日期、null 这么几个，字符串必须用双引号引起来，其余的都不用

优点：

1. 基于纯文本，跨平台传递极其简单；
2. Javascript 原生支持，后台语言几乎全部支持；
3. 轻量级数据格式，占用字符数量极少，特别适合互联网传递；
4. 可读性较强，虽然比不上 XML 那么一目了然，但在合理的依次缩进之后还是很容易识别的；
5. 容易编写和解析，当然前提是你要知道数据结构；

## XML

- XML 指可扩展标记语言（EXtensible Markup Language）
- XML 是一种标记语言，很类似 HTML
- XML 的设计宗旨是传输数据，而非显示数据
- XML 标签没有被预定义。您需要自行定义标签。

AJAX 可用来与 XML 文件进行交互式通信。

loadXMLDoc() 函数创建 XMLHttpRequest 对象，添加当服务器响应就绪时执行的函数，并将请求发送到服务器。
当服务器响应就绪时，会构建一个 HTML 表格，从 XML 文件中提取节点（元素），最后使用 XML 数据的 填充 id="demo" 的表格元素：

```javascript
function loadDoc() {
  let xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      myFunction(this);
    }
  };
  xhttp.open("GET", "cd_catalog.xml", true);
  xhttp.send();
}
function myFunction(xml) {
  var i;
  var xmlDoc = xml.responseXML;
  var table="<tr><th>Artist</th><th>Title</th></tr>";
  var x = xmlDoc.getElementsByTagName("CD");
  for (i = 0; i <x.length; i++) {
    table += "<tr><td>" +
    x[i].getElementsByTagName("ARTIST")[0].childNodes[0].nodeValue +
    "</td><td>" +
    x[i].getElementsByTagName("TITLE")[0].childNodes[0].nodeValue +
    "</td></tr>";
  }
  document.getElementById("demo").innerHTML = table;
```

## 状态码

补全状态码避免再去搜:
100——客户必须继续发出请求
101——客户要求服务器根据请求转换 HTTP 协议版本
200——交易成功
201——提示知道新文件的 URL
202——接受和处理、但处理未完成
203——返回信息不确定或不完整
204——请求收到，但返回信息为空
205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
206——服务器已经完成了部分用户的 GET 请求
300——请求的资源可在多处得到
301——删除请求数据
302——在其他地址发现了请求数据
303——建议客户访问其他 URL 或访问方式
304——客户端已经执行了 GET，但文件未变化
305——请求的资源必须从服务器指定的地址得到
306——前一版本 HTTP 中使用的代码，现行版本中不再使用
307——申明请求的资源临时性删除
400——错误请求，如语法错误
401——请求授权失败
402——保留有效 ChargeTo 头响应
403——请求不允许
404——没有发现文件、查询或 URl
405——用户在 Request-Line 字段定义的方法不允许
406——根据用户发送的 Accept，请求资源不可访问
407——类似 401，用户必须首先在代理服务器上得到授权
408——客户端没有在用户指定的饿时间内完成请求
409——对当前资源状态，请求不能完成
410——服务器上不再有此资源且无进一步的参考地址
411——服务器拒绝用户定义的 Content-Length 属性请求
412——一个或多个请求头字段在当前请求中错误
413——请求的资源大于服务器允许的大小
414——请求的资源 URL 长于服务器允许的长度
415——请求资源不支持请求项目格式
416——请求中包含 Range 请求头字段，在当前请求资源范围内没有 range 指示值，请求也不包含 If-Range 请求头字段
417——服务器不满足请求 Expect 头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求
500——服务器产生内部错误
501——服务器不支持请求的函数
502——服务器暂时不可用，有时是为了防止发生系统过载
503——服务器过载或暂停维修
504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长
505——服务器不支持或拒绝支请求头中指定的 HTTP 版本
