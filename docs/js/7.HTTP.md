# HTTP

## 基础

HTTP 协议，HyperText Transfer Protocol（超文本传输协议）

1. 支持 C/S 模式。(C/S 客户端-服务器,B/S 浏览器-服务器)
2. 基于 TCP/IP 通信协议来传递数据
3. 通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性
4. 应用层的面向对象的协议
5. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。
6. 灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记
7. 无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，可以节省传输时间。
8. 无状态：协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

> 注：HTTP 的默认端口号为 80，HTTPS 的默认端口号为 443。

### 历史版本

- HTTP/1.0：传输内容格式不限制，增加 PUT、PATCH、HEAD、 OPTIONS、DELETE 命令
- HTTP/1.1：持久连接(长连接)、节约带宽、HOST 域、管道机制、分块传输编码
- HTTP/2：多路复用（通过单一的 HTTP/2 连接请求发起多重的请求-响应消息，多个请求 stream 共享一个 TCP 连接，实现多留并行而不是依赖建立多个 TCP 连接）、服务器推送、头信息压缩、二进制协议等 | 逐渐覆盖市场

## TCP/IP

> TCP: Transmission Control Protocol 传输控制协议，负责应用软件（比如你的浏览器）和网络软件之间的通信
> IP: Internet Protocol 网际协议，计算机用来相互识别的通信的一种机制

- TCP/IP 协议族是按层次去划分的
  - 应用层，决定了向用户提供应用服务时通信的活动。
    - FTP 协议（文件传输协议）
    - DNS（域名协议）
    - HTTP（超文本传输协议）
  - 传输层，提供处于网络连接中两台计算机之间的数据传输
    - TCP（传输控制协议）
    - UDP（用户数据报协议）
  - 网络层，用来处理在网络上流动的数据包
    - IP 协议
  - 数据链路层，用来处理连接网络的硬件设备### 三次握手

首先，客户端与服务器均处于未连接状态，并且是客户端主动向服务器请求建立连接：

客户端将报文段中的 SYN=1，并选择一个 seq=x，(即该请求报文的序号为 x) 将这个报文发送到服务器。此时，客户端进入同步已发送状态（SYN-SEND）.SYN 报文段不能携带数据，但是要消耗掉一个序号。
服务器收到请求报文后，若同意建立连接，则回复报文中，SYN=1,ACK=1，并选择一个 seq = y,且报文中确认号为 x+1，序号为 y .此时服务器进入同步已接收状态（SYN-RCVD）

客户端收到服务器的同步确认后，对服务器发送确认的确认。将 ACK=1,确认号为 y+1,而报文首部的序号为 x+1，将该报文发出后，客户端进入已连接状态（ESTABLISHED）。

服务器收到客户端的确认后，也进入已连接状态。即三次握手

### 四次挥手

连接的释放较连接的建立复杂。

现假设客户端与服务器均处于连接建立状态，客户端主动断开连接：

1. 客户端向服务器发送 FIN 报文：FIN=1,序号 seq=上一个最后传输的字节序号+1=u，发送后，客户端进入 FIN-WAIT-1 状态。
2. 服务器接收到该报文后，发送一个确认报文：令 ACK=1，确认序号 ack = u+1,自己的报文序号 seq=v，发送后，服务器进入 CLOSE-WAIT 状态。
3. 此时 TCP 连接进入连接半关闭状态，服务器可能还会向客户端发送一些数据。
4. 客户端收到来自服务器的确认之后，进入 FIN-WAIT-2 状态。等待服务器发送连接释放报文。
5. 如果服务器已经没有要发送的数据，则释放 TCP 连接，向客户端发送报文：令 FIN=1，ACK=1,确认号 ack =u+1，自己的序号 seq = w（w 可能等于 v 也可能大于 v），服务器进入 LAST-ACK 状态。
6. 客户端收到服务器的连接释放报文后，对该报文发出确认，令 ACK=1,确认号 ack=w+1，自己的序号 seq=u+1，发送此报文后，等待 2 个 msl 时间后，进入 CLOSED 状态。
7. 服务器收到客户端的确认后，也进入 CLOSED 状态并撤销传输控制块。

客户端状态变化：未连接----->SYN-SEND----->ESTABLISHED----->FIN-WAIT-1----->FIN-WAIT-2----->TIME-WAIT----->CLOSED

服务器状态变化：未连接----->SYN-RCVD----->ESTABLISHED----->CLOSE-WAIT----->LAST-ACK----->CLOSED

## DNS

DNS 查找流程：

1. 查找浏览器缓存
2. 查找系统缓存
3. 查找路由器缓存
4. 查找 ISP DNS 缓存（网络运营商）
5. 递归搜索。本地 DNS 服务器即将该请求转发到互联网上的根域，查找不到再追击向上

- DNS 的查找是有开销的
- 在 DNS 查找完成之前，浏览器不能从主机下载任何东西
- DNS 可以被缓存起来提高性能的，这种缓存可以发生在网络运营商的服务器上，也可以发在本机所处的局域网中，甚至可以发生在本地的操作系统或浏览器中
- 但是服务器的 IP 地址是可变的，缓存会消耗内存，因此不管是哪个级别的缓存都应该周期性的清除一下。

优化：

1. 一个多资源的站点最好使用 2 到 4 个不一样的主机来存放服务端资源。这是在减少 DNS 查询和允许高度并行下载之间作出的最好权衡(高度并行下载,浏览器一次能并发加载的量是受域名控制的)
2. 使用 Keep-alive 进行持久连接

在使用 CDN 的过程中，当用户点击网站页面上的内容 URL，经过本地 DNS 系统解析，DNS 系统会最终将域名的解析权交给 CNAME 指向的 CDN 专用 DNS 服务器

### 请求字段

#### 请求头

用于传递一些附加信息，格式为：`键: 值`

- Content-Type：请求体/响应体的类型
  - text/plain、application/json
- Accept：客户端能够处理的媒体类型，可以多个值，用`,`分开
  - 文本文件：text/html, text/plain, text/css, application/xml
  - 图片文件：iamge/jpeg, image/gif, image/png
  - 视频文件：video/mpeg
  - 应用程序使用的二进制文件：application/octet-stream, application/zip
- Accept-Charset：表示客户端支持的字符集
- Content-length：请求体/响应体的长度，单位字节
- Content-Encoding：请求体/响应体的编码格式
  - gzip: 由文件压缩程序 gzip 生成的编码格式；
  - compress: 由 Unix 文件压缩程序 compress 生成的编码格式；
  - deflate: 组合使用 zlib 和 deflate 压缩算法生成的编码格式；
  - identity：默认的编码格式，不执行压缩。
- Accept-Encoding：告知对方接受的 Content-Encoding
- Cache-Control：取值一般为 no-cache、max-age=xx，xx 为整数，表示资源缓存有效期（秒）
- ETag：给当前资源的标识，和 Last-Modified、If-None-Match、If-Modified-Since 配合，用于缓存控制
- Authorization：用于设置身份认证信息
- User-Agent：用户标识。
- If-Match：与所请求资源的 ETag 值（实体标记，与资源相关联。资源变化，实体标记跟着变化）一致时，服务器才处理此请求。
- If-Modified-Since：上一次服务器返回的 Last-Modified 值，用于确定某个资源是否被更改过，没有更改过就从缓存中读取
- If-None-Match：与所请求资源的 ETag 值不一致时服务器才处理此请求
- Cookie：已有 Cookie
- Referer：标识请求引用自哪个地址
- Host：请求的主机和端口号

#### 请求体

### 响应

```text
HTTP/版本号 返回码 返回码描述
应答首部字段(可选)
空行
body
```

- Age：源服务器（而不是缓存服务器）在多久之前创建了响应
- ETag： 实体资源的标识，可用来请求指定的资源
- Location：请求的资源所在的新位置
- Proxy-Authenticate：将代理服务器需要的认证信息发送给客户端
- Retry-After：服务端告知客户端多久之后再重试，一般与 503 和 3xx 重定向类型的应答一起使用
- Server：告知服务端当前使用的 HTTP 服务器应用程序的相关信息
- WWW-Authenticate：告知客户端适用于所访问资源的认证方案，如 Basic 或 Digest。401 的响应中肯定带有
- Content-Encoding：告知客户端，服务器对资源的内容编码
- Content-Language：告知客户端，资源所使用的自然语言
- Content-Length：告知客户端资源的长度
- Content-Location：告知客户端资源所在的位置
- Content-Type：告知客户端资源的媒体类型，取值同请求首部字段中的 Accept
- Last-Modified：告知客户端资源最后一次修改的时间。

### URL

使用 HTTP 协议访问资源是通过 URL（Uniform Resource Locator）统一资源定位符来实现的。URL 的格式如下：

```text
scheme://host:port/path?query

scheme: 表示协议，如Http, Https, Ftp等；
host: 表示所访问资源所在的主机名：如：www.abc.com;
port: 表示端口号，默认为80；
path: 表示所访问的资源在目标主机上的储存路径；
query: 表示查询条件；

例如： http://www.abc.com/search?words=abc
```

> [URI](https://developer.mozilla.org/en-US/docs/Glossary/URI)：统一资源标识符，而 URL 是统一资源定位符。每个 URL 都是 URI，但不一定每个 URI 都是 URL。URI 还包括一个子类，统一资源名称 (URN)，它命名资源但不指定如何定位资源。

一般情况下，资源的名称和位置由同一个 URL（统一资源定位符，它是 URI 的一种）来标识。也有某些特殊情况，资源的名称和位置由不同的 URI 进行标识：例如，待请求的资源希望客户端从另外一个位置访问它。我们可以使用一个特定的首部字段，[`Alt-Svc`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Alt-Svc)，来指示这种情况。

## HTTPS

HTTP 是明文传输的，这就意味着介于发送端和接收端之间的任意节点都可以知道传输的内容是什么，这些节点可以是路由器、代理等

HTTPS，经由 HTTP 进行通信，利用 SSL/TLS 建立全信道，加密数据包。HTTPS 比 HTTP 多了一层 TLS/SSL 协议

TLS（传输层安全）跟 SSL（安全套接字）可以理解成类似的东西，可以将 SSL 理解成负责对 HTTP 的数据进行加密的加密套件，而 TLS 是 SSL 的升级版/继任者。

TLS 的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥， 然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。

### 身份验证 CA 和证书

解决身份验证问题的关键是确保获取的公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构 CA(如沃通 CA)。CA 负责核实公钥的拥有者的信息，并颁发认证"证书"，同时能够为使用者提供证书验证服务，即 PKI 体系(PKI 基础知识)。
基本的原理为，CA 负责审核信息，然后对关键信息利用私钥进行"签名"，公开对应的公钥，客户端可以利用公钥验证签名。

### 特点

- 内容加密：采用混合加密技术，中间者无法直接查看明文内容
- 验证身份：通过证书认证客户端访问的是自己的服务器
- 保护数据完整性：防止传输的内容被中间人冒充或者篡改

**混合加密：**结合非对称加密和对称加密技术。客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，所以网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘密秘钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的秘钥，便无法获取到明文数据。

**数字摘要：**通过单向 hash 函数对原文进行哈希，将需加密的明文“摘要”成一串固定长度(如 128bit)的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文。

**数字签名技术：**数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥加密技术和数字摘要结合起来，形成了实用的数字签名技术。

> 非对称加密过程需要用到公钥进行加密，那么公钥从何而来？其实公钥就被包含在数字证书中，数字证书通常来说是由受信任的数字证书颁发机构 CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。

### 缺点

- SSL 证书需要购买申请，功能越强大的证书费用越高
- SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗（SSL 有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP 就不支持这个扩展，考虑到 XP 的装机量，这个特性几乎没用）。
- 根据 ACM CoNEXT 数据显示，使用 HTTPS 协议会使页面的加载时间延长近 50%，增加 10%到 20%的耗电。
- HTTPS 连接缓存不如 HTTP 高效，流量成本高。
- HTTPS 连接服务器端资源占用高很多，支持访客多的网站需要投入更大的成本。
- HTTPS 协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方式是采用分而治之，类似 12306 网站的主页使用 HTTP 协议，有关于用户信息等方面使用 HTTPS。

## HTTP2

HTTP2 采用二进制格式传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效。
多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。在 HTTP1.x 中，并发多个请求需要多个 TCP 连接，浏览器为了控制资源会有 6-8 个 TCP 连接都限制。

HTTP2 中：

- 同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。就是在一个 TCP 连接中可以存在多条流，多路复用
- 单个连接上可以并行交错的请求和响应，之间互不干扰

## ajax

Asynchronous [e'sɪŋkrənəs] Javascript And XML， AJAX 不是一门的新的语言，而是对现有技术的综合利用。 本质是在 HTTP 协议的基础上以异步的方式与服务器进行通信。

### XMLHttpRequest 对象

浏览器内建对象，用于与服务器通信(交换数据)

### GET 和 POST 请求的区别

1. HTTP 没有要求，如果 Method 是 POST 数据就要放在 BODY 中。也没有要求，如果 Method 是 GET，数据（参数）就一定要放在 URL 中而不能放在 BODY 中。但在浏览器中，GET 提交的数据会放在 URL 之后，POST 是把提交的数据放在 HTTP 消息的 Body 中
2. HTTP 协议从未规定过 GET/POST 请求长度是多少，GET 提交的数据大小有限制是某些浏览器或服务器对 URL 的长度有限制，而 POST 方法提交的数据没有限制
3. 多数浏览器对于 POST 采用两阶段发送数据的
4. GET 方式请求的数据会被浏览器缓存起来
5. GET 幂等，而 POST 请求不是

> 幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一 URL 的多个请求应该返回同样的结果。

### 跨域

浏览器的同源策略限制，浏览器会拒绝跨域请求

#### 简单请求和非简单请求

简单请求：使用下列方法之一且没有人为设置对 CORS 安全的首部字段集合之外的其他首部字段：

```text
GET
HEAD
POST- 仅当POST方法的Content-Type值等于下列之一才算作简单请求
 - text/plain
 - multipart/form-data
 - application/x-www-form-urlencoded
```

#### JSONP

利用资源请求标签（script）可引入不同域上的 js 脚本，在 js 文件载入完毕之后，触发回调

优点：兼容性好（兼容低版本 IE）
缺点：1.JSONP 只支持 GET 请求； 2.错误处理机制缺失

#### CORS

```text
Access-Control-Allow-Origin: foo.example    // 标识可接受的跨域请求源；  Access-Control-Allow-Methods: POST, GET, OPTIONS   //标识可接受的跨域请求方法,如GET、POST、OPTIONS；
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type //标识可接受的跨域请求自定义头；
Access-Control-Max-Age: 86400。 //标识本次预请求的有效时间（秒），期间内无需再发送预请求；
```

#### postMessage

window.postMessage(message,targetOrigin) 方法是 html5 新引进的特性，可以使用它来向其它的 window 对象发送消息

```js
var channel = new MessageChannel();
var output = document.querySelector(".output");
var iframe = document.querySelector("iframe");

// Wait for the iframe to load
iframe.addEventListener("load", onLoad);

function onLoad() {
  // Listen for messages on port1
  channel.port1.onmessage = onMessage;

  // Transfer port2 to the iframe
  iframe.contentWindow.postMessage("Hello from the main page!", "*", [
    channel.port2
  ]);
}

// Handle messages received on port1
function onMessage(e) {
  output.innerHTML = e.data;
}
```

## fetch

```javascript
fetch(url, options).then(
  response => {
    // handle HTTP response
  },
  error => {
    // handle network error
  }
);
```

说明：

1. fetch api 返回的是一个 promise 对象
2. Options:
   - method(String): HTTP 请求方法，默认为 GET
   - body(String): HTTP 的请求参数
   - headers(Object): HTTP 的请求头，默认为{}
   - credentials(String): 默认为 omit,忽略的意思，也就是不带 cookie;还有两个参数，same-origin，意思就是同源请求带 cookie；include,表示无论跨域还是同源请求都会带 cookie
3. 第一个 then 函数里面处理的是 response 的格式
   - status(number): HTTP 返回的状态码，范围在 100-599 之间
     statusText(String): 服务器返回的状态文字描述，例如 Unauthorized,上图中返回的是 Ok
     ok(Boolean): 如果状态码是以 2 开头的，则为 true
     headers: HTTP 请求返回头
     body: 返回体，这里有处理返回体的一些方法
     text(): 将返回体处理成字符串类型
     json()： 返回结果和 JSON.parse(responseText)一样
     blob()： 返回一个 Blob，Blob 对象是一个不可更改的类文件的二进制数据
     arrayBuffer()
     formData()

### 问题

1. 兼容性
   IE 浏览器完全不支持 fetch，移动端的很多浏览器也不支持,所以，如果要在这些浏览器上使用 Fetch，就必须使用 fetch polyfill
2. cookie 传递
   必须在 header 参数里面加上 credientials: 'include'，才会如 xhr 一样将当前 cookies 带到请求中去
3. fetch 和 xhr 的不同
   fetch 虽然底层，但是还是缺少一些常用 xhr 有的方法，比如能够取消请求（abort）方法。fetch 在服务器返回 4xx、5xx 时是不会抛出错误的，这里需要手动通过，通过 response 中的 ok 字段和 status 字段来判断

## JSON

JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript 规范，采用独立于编程语言的文本格式来存储和表示数据。

特点：

- 数据在 键值对 中
- 数据由逗号分隔(最后一个 键值对 不能带逗号)
- 花括号保存对象，方括号保存数组
- 键使用双引号
- JSON 内部常用数据类型无非就是字符串、数字、布尔、日期、null 这么几个，字符串必须用双引号引起来，其余的都不用

优点：

- 基于纯文本，跨平台传简单；
- JavaScript 原生支持，后台语言几乎全部支持；
- 轻量级数据格式，占用字符数量少，适合互联网传递；
- 可读性较强
- 容易编写和解析

## XML

- XML 指可扩展标记语言（EXtensible Markup Language）
- XML 是一种标记语言，类似 HTML
- XML 的设计宗旨是传输数据，而非显示数据
- XML 标签没有被预定义，自行定义标签。

AJAX 可用来与 XML 文件进行交互式通信。

loadXMLDoc() 函数创建 XMLHttpRequest 对象，添加当服务器响应就绪时执行的函数，并将请求发送到服务器。
当服务器响应就绪时，会构建一个 HTML 表格，从 XML 文件中提取节点（元素），最后使用 XML 数据的 填充 id="demo" 的表格元素：

```javascript
function loadDoc() {
  let xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      myFunction(this);
    }
  };
  xhttp.open("GET", "cd_catalog.xml", true);
  xhttp.send();
}
function myFunction(xml) {
  let i;
  let xmlDoc = xml.responseXML;
  let table="<tr><th>Artist</th><th>Title</th></tr>";
  let x = xmlDoc.getElementsByTagName("CD");
  for (i = 0; i <x.length; i++) {
    table += "<tr><td>" +
    x[i].getElementsByTagName("ARTIST")[0].childNodes[0].nodeValue +
    "</td><td>" +
    x[i].getElementsByTagName("TITLE")[0].childNodes[0].nodeValue +
    "</td></tr>";
  }
  document.getElementById("demo").innerHTML = table;
```

## 状态码

100——客户必须继续发出请求
101——客户要求服务器根据请求转换 HTTP 协议版本
200——交易成功
201——提示知道新文件的 URL
202——接受和处理、但处理未完成
203——返回信息不确定或不完整
204——请求收到，但返回信息为空
205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
206——服务器已经完成了部分用户的 GET 请求
300——请求的资源可在多处得到
301——删除请求数据
302——在其他地址发现了请求数据
303——建议客户访问其他 URL 或访问方式
304——客户端已经执行了 GET，但文件未变化
305——请求的资源必须从服务器指定的地址得到
306——前一版本 HTTP 中使用的代码，现行版本中不再使用
307——申明请求的资源临时性删除
400——错误请求，如语法错误
401——请求授权失败
402——保留有效 ChargeTo 头响应
403——请求不允许
404——没有发现文件、查询或 URl
405——用户在 Request-Line 字段定义的方法不允许
406——根据用户发送的 Accept，请求资源不可访问
407——类似 401，用户必须首先在代理服务器上得到授权
408——客户端没有在用户指定的饿时间内完成请求
409——对当前资源状态，请求不能完成
410——服务器上不再有此资源且无进一步的参考地址
411——服务器拒绝用户定义的 Content-Length 属性请求
412——一个或多个请求头字段在当前请求中错误
413——请求的资源大于服务器允许的大小
414——请求的资源 URL 长于服务器允许的长度
415——请求资源不支持请求项目格式
416——请求中包含 Range 请求头字段，在当前请求资源范围内没有 range 指示值，请求也不包含 If-Range 请求头字段
417——服务器不满足请求 Expect 头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求
500——服务器产生内部错误
501——服务器不支持请求的函数
502——服务器暂时不可用，有时是为了防止发生系统过载
503——服务器过载或暂停维修
504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长
505——服务器不支持或拒绝支请求头中指定的 HTTP 版本

## Server-sent events

```javascript
const evtSource = new EventSource("ssedemo.php");
evtSource.onmessage = function(e) {
  var newElement = document.createElement("li");

  newElement.innerHTML = "message: " + e.data;
  eventList.appendChild(newElement);
};
```

## WebSocket

WebSocket 是一种网络通信协议。

因为 HTTP 协议有一个缺陷：通信只能由客户端发起，HTTP 协议做不到服务器主动向客户端推送信息。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用"轮询"：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。

WebSocket 协议在 2008 年诞生，2011 年成为国际标准。所有浏览器都已经支持了。

特点：

- 服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。
- 建立在 TCP 协议之上，服务器端的实现比较容易。
- 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
- 数据格式比较轻量，性能开销小，通信高效。
- 可以发送文本，也可以发送二进制数据。
- 没有同源限制，客户端可以与任意服务器通信。
- 协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。

```javascript
var ws = new WebSocket("wss://echo.websocket.org");

ws.onopen = function(evt) {
  console.log("Connection open ...");
  ws.send("Hello WebSockets!");
};

ws.onmessage = function(evt) {
  console.log("Received Message: " + evt.data);
  ws.close();
};

ws.onclose = function(evt) {
  console.log("Connection closed.");
};
```

### 构造函数

```javascript
var ws = new WebSocket("ws://localhost:8080");
```

此时，客户端会与服务端进行链接

### readyState

readyState 属性返回实例对象的当前状态，共有四种。

- CONNECTING：值为 0，表示正在连接。
- OPEN：值为 1，表示连接成功，可以通信了。
- CLOSING：值为 2，表示连接正在关闭。
- CLOSED：值为 3，表示连接已经关闭，或者打开连接失败。

```javascript
switch (ws.readyState) {
  case WebSocket.CONNECTING:
    // do something
    break;
  case WebSocket.OPEN:
    // do something
    break;
  case WebSocket.CLOSING:
    // do something
    break;
  case WebSocket.CLOSED:
    // do something
    break;
  default:
    // this never happens
    break;
}
```

### onopen

websocket 实例对象的属性，用于指定连接成功后的回掉函数

```javascript
ws.onopen = function() {
  ws.send("Hello Server");
};
```

如果要指定多个回调函数，可以使用 addEventListener 方法。

```javascript
ws.addEventListener("open", function(event) {
  ws.send("Hello Server!");
});
```

### onclose

实例对象的 onclose 属性，用于指定连接关闭后的回调函数。

```javascript
ws.onclose = function(event) {
  var code = event.code;
  var reason = event.reason;
  var wasClean = event.wasClean;
  // handle close event
};

ws.addEventListener("close", function(event) {
  var code = event.code;
  var reason = event.reason;
  var wasClean = event.wasClean;
  // handle close event
});
```

### onmessage

实例对象的 onmessage 属性，用于指定收到服务器数据后的回调函数。

```javascript
ws.onmessage = function(event) {
  var data = event.data;
  // 处理数据
};

ws.addEventListener("message", function(event) {
  var data = event.data;
  // 处理数据
});
```

> 注意，服务器数据可能是文本，也可能是二进制数据（blob 对象或 Arraybuffer 对象）。

除了动态判断收到的数据类型，也可以使用 binaryType 属性，显式指定收到的二进制数据类型。

```javascript
// 收到的是 blob 数据
ws.binaryType = "blob";
ws.onmessage = function(e) {
  console.log(e.data.size);
};

// 收到的是 ArrayBuffer 数据
ws.binaryType = "arraybuffer";
ws.onmessage = function(e) {
  console.log(e.data.byteLength);
};
```

### send

实例对象的 send()方法用于向服务器发送数据。

发送文本的例子。

```javascript
ws.send("your message");
```

发送 Blob 对象的例子。

```javascript
var file = document.querySelector('input[type="file"]').files[0];
ws.send(file);
```

发送 ArrayBuffer 对象的例子。

```javascript
// Sending canvas ImageData as ArrayBuffer
var img = canvas_context.getImageData(0, 0, 400, 320);
var binary = new Uint8Array(img.data.length);
for (var i = 0; i < img.data.length; i++) {
  binary[i] = img.data[i];
}
ws.send(binary.buffer);
```

### bufferedAmount

实例对象的 bufferedAmount 属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。

```javascript
var data = new ArrayBuffer(10000000);
socket.send(data);

if (socket.bufferedAmount === 0) {
  // 发送完毕
} else {
  // 发送还没结束
}
```

### onerror

```javascript
socket.onerror = function(event) {
  // handle error event
};

socket.addEventListener("error", function(event) {
  // handle error event
});
```
