# 缓存

## 缓存机制

### 缓存

- 即便缓存服务器（客户端浏览器）内有缓存文件，也不能保证每次都会使用到对应资源的缓存，这和被缓存资源的有效性有关
- 列如客户端的要求，缓存的有效期等
- 当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就演变成返回更新前的旧资源了

### 客户端自己决定的缓存策略

### 实体首部字段 Expires（响应）——http 1.0

1. 首部字段 Expires 会将资源失效的日期告知客户端，缓存服务器在接收到含有首部字段 Expires 的响应后，
2. 会以缓存来应答请求。在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后
3. 缓存服务器在请求发送过来时，会转向源服务器请求资源。
4. 源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。
5. 但是在首部字段 cache-control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令

### 通用首部字段 cache-control —— http 1.1

| 响应指令    | 说明                       |
| ----------- | -------------------------- |
| max-age[秒] | 响应的最大 age 值          |
| no-cache    | 缓存前必须先确认其有效性   |
| no-store    | 不缓存请求或响应的任何内容 |

- 首部字段 cache-control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令

### 客户端与服务端协商的缓存策略

- 当我们第一次输入一个地址 <https://www.zhipin.com/>

  - 响应头：

    ```
    cache-control: no-cache  //协商缓存
    etag: "5b3e2d1b-13dd"
    last-modified: Thu, 05 Jul 2018 14:37:15 GMT
    ```

- 当我们第二次输入地址访问：

  - 请求头：

    ```
    if-modified-since: Thu, 05 Jul 2018 14:37:15 GMT
    if-none-match: "5b3e2d1b-13dd"
    ```

  - 响应头：

    ```
    cache-control: no-cache  //协商缓存
    etag: "5b3e2d1b-13dd"
    last-modified: Thu, 05 Jul 2018 14:37:15 GMT
    ```

- **强制缓存**（强制读取缓存）

  ```
  Cache-Control: max-age=315360000   http 1.1
  Expires: Tue, 04 Jul 2028 08:03:30 GMT  http 1.0
  ```

### 实体首部字段 last-modified（响应）& 请求首部字段 if-modified-since

- 首部 last-modified 指明资源最终修改的时间，一般来说，这个值就是资源被修改的时间。

- 首部字段 if-modified-since

  第一次请求资源时，资源在响应头中种入 last-modified 字段，并随着响应体一起存到缓存中

  下一次需要再发送请求时，请求体中会将上一次修改时间（last-modified）种入 if-modified-since 字段中

- 带到服务端，它会告知服务器，若在 if-modified-since 字段值之后 对应的资源都没有更新过则返回 304 Not Modified 状态码

  若在 if-modified-since 字段值之后 对应的资源有过更新 则希望服务器能处理

- 此处的客户端与服务端协商的缓存策略一般与 cache-control 一块使用。需要在 cache-control 失效后再走这种缓存策略

- **缺点**：

  1. 某些服务端没有办法获取精确的修改时间，导致 last-modified 有问题

  1. 文件时间修改了，但文件内容却没有变

### 响应首部字段 etag & 请求首部字段 if-None-Match

- 响应首部字段 etag：

  它可以告知客户端实体标识，它是一种可以将资源以字符串做唯一标识的方式，服务器会为每份资源分配对应的 Etag 值。

  另外当资源更新时，etag 的值也需要更新，这个唯一标识的生成没有规定统一的算法，由服务器自行决定

- 请求首部字段 if-None-Match

  机制和 if-modified-since 差不多，当 if-None-Match 字段与 etag 不一致时，就告知服务器该处理这请求

- 此处的客户端与服务端协商的缓存策略一般与 cache-control 一块使用。需要在 cache-control 失效后再走这种缓存策略

### 分级缓存策略

http 缓存机制

1. **200 from cache**

   ```
    这一层由exprise(http1.0)、cache-control(http1.1)控制
   ```

   cache-control 的优先级要高于 exprise
   当它们没有失效时，浏览器只能访问总结的缓存

2. **304 状态**

   ```
    这一层由last-modified或etag来控制，
   ```

   etag 优先级比 last-modified 高
   当上一层失效时，用户刷新时浏览器会发请求给服务器，如果服务端没有变化这返回 304 给浏览器

3. **200 状态**

   ```
    当上两层都失效时，浏览器会去服务器下载最新的数据
   ```
