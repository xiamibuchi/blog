# 内存空间

与C/C++不同，JavaScript中并没有严格意义上区分栈内存与堆内存。因此我们可以简单粗暴的理解为JavaScript的所有数据都保存在堆内存中。但是在某些场景，我们仍然需要基于堆栈数据结构的思维来实现一些功能，比如JavaScript的执行上下文。执行上下文的执行顺序借用了栈数据结构的存取方式。

## 堆，栈与队列

堆(heap)，栈(stack)与队列(queue)

栈空间先进后出，后进先出的特点
队列是一种先进先出（FIFO）的数据结构

## JavaScript 垃圾收集机制

javascript具有自动垃圾收集机制，执行环境会负责管理代码执行过程中的使用的内存。
JavaScript中最常用的垃圾收集方式是标记清除(mark-and-sweep)。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占的内存，因为只要执行流进入相应的环境，就可能用到它们。而当变量离开环境时，这将其 标记为“离开环境”。

### V8的垃圾回收机制

V8将堆中的对象分为两类：

新生代：年轻的新对象，未经历垃圾回收或仅经历过一次
老年代：存活时间长的老对象，经历过一次或更多次垃圾回收的对象

默认情况下，V8为老年代分配的空间，大概是新生代的40多倍。
新对象都会被分配到新生代中，当新生代空间不足以分配新对象时，将触发新生代的垃圾回收。

新生代的垃圾回收
新生代中的对象主要通过Scavenge算法进行垃圾回收，这是一种采用复制的方式实现内存回收的算法。
Scavenge算法将新生代的总空间一分为二，只使用其中一个，另一个处于闲置，等待垃圾回收时使用。使用中的那块空间称为From，闲置的空间称为To。From与To各占一半，当新生代触发垃圾回收时，V8将From空间中所有应该存活下来的对象依次复制到To空间。

有两种情况不会将对象复制到To空间，而是晋升至老年代：

对象此前已经经历过一次新生代垃圾回收，这次依旧应该存活，则晋升至老年代。
To空间已经使用了25%，则将此对象直接晋升至老年代。

From空间所有应该存活的对象都复制完成后，原本的From空间将被释放，成为闲置空间，原本To空间则成为使用中空间，两个空间进行角色翻转。
为何To空间使用超过25%时，就需要直接将对象复制到老年代呢？因为To空间完成垃圾回收后将会翻转为From空间，新的对象分配都在此处进行，如果没有足够的空闲空间，将会影响程序的新对象分配。
因为Scavenge只复制活着的对象，而根据统计学指导，新生代中大多数对象寿命都不长，长期存活对象少，则需要复制的对象相对来说很少，因此总体来说，新生代使用Scavenge算法的效率非常高。且由于Scavenge是依次连续复制，所以To空间永远不会存在内存碎片。
不过由于Scavenge会将空间对半划分，所以此算法的空间利用率较低。

老年代的垃圾回收
在老年代中的对象，至少都已经历过一次甚至更多次垃圾回收，相对于新生代中的对象，它们有更大的概率继续存活，只有相对少数的对象面临死亡，且由于老年代的堆内存是新生代的几十倍，其中生活着大量对象，因此如果使用Scavenge算法回收老年代，将会面临大量的存活对象需要复制的情况，将老年代空间对半划分，也会浪费相当大的空间，效率低下。因此老年代垃圾回收主要采用标记清除(Mark-Sweep)和标记整理(Mark-Compact)。
这两种方式并非互相替代关系，而是配合关系，在不同情况下，选择不同方式，交替配合以提高回收效率。
新生代中死亡对象占多数，因此采用Scavenge算法只处理存活对象，提高效率。老年代中存活对象占多数，于是采用标记清除算法只处理死亡对象，提高效率。
当老年代的垃圾回收被触发时，V8会将需要存活对象打上标记，然后将没有标记的对象，也就是需要死亡的对象，全部擦除，一次标记清除式回收就完成了：

灰色为存活对象，白色为清除后的闲置空间

一切看起来都完美了，可是随着程序的继续运行，却会出现一个问题：被清除的对象遍布各个内存地址，空间有大有小，其闲置空间不连续，产生了很多内存碎片。当需要将一个足够大的对象晋升至老年代时，无法找到一个足够大的连续空间安置这个对象。
为了解决这种空间碎片的问题，就出现了标记整理算法。它是在标记清除的基础上演变而来，当清理了死亡对象后，它会将所有存活对象往一端移动，使其内存空间紧挨，另一端就成为了连续内存：

虽然标记整理算法可以避免空间碎片，但是却需要依次移动对象，效率比标记清除算法更低，因此大多数情况下V8会使用标记清理算法，当空间碎片不足以安放新晋升对象时，才会触发标记整理算法。

增量标记（Incremental Marking）

早期V8在垃圾回收阶段，采用全停顿（stop the world），也就是垃圾回收时程序运行会被暂停。这在JavaScript还仅被用于浏览器端开发时，并没有什么明显的缺点，前端开发使用的内存少，大多数时候仅触发新生代垃圾回收，速度快，卡顿几乎感觉不到。但是对于Node程序，使用内存更多，在老年代垃圾回收时，全停顿很容易带来明显的程序迟滞，标记阶段很容易就会超过100ms，因此V8引入了增量标记，将标记阶段分为若干小步骤，每个步骤控制在5ms内，每运行一段时间标记动作，就让JavaScript程序执行一会儿，如此交替，明显地提高了程序流畅性，一定程度上避免了长时间卡顿。

Node开发中的内存管理与优化

2.1 手动变量销毁
当任一作用域存活于作用域栈（作用域链）时，其中的变量都不会被销毁，其引用的数据也会一直被变量关联，得不到GC。有的作用域存活时间非常长（越是栈底，存活时间越长，最长的是全局作用域），但是其中的某些变量也许在某一时刻后就没有用处了，因此建议手动设置为null，断开引用链接，使得V8可以及时GC释放内存。
注意，不使用var声明的变量，都会成为全局对象的属性。前端开发中全局对象为window，Node中全局对象为global，如果global中有属性已经没有用处了，一定要设置为null，因为全局作用域只有等到程序停止运行，才会销毁。
Node中，当一个模块被引入，这个模块就会被缓存在内存中，提高下次被引用的速度。也就是说，一般情况下，整个Node程序中对同一个模块的引用，都是同一个实例（instance），这个实例一直存活在内存中。所以，如果任意模块中有变量已经不再需要，最好手动设置为null，不然会白白占用内存，成为“活着的死对象”。

## 常见内存泄漏

虽然JavaScript 会自动垃圾收集，但是如果我们的代码写法不当，会让变量一直处于“进入环境”的状态，无法被回收。下面列一下内存泄露常见的几种情况。

### 全局变量引起的内存泄漏

```javascript
function leaks(){
    leak = 'xxxxxx';//leak 成为一个全局变量，不会被回收
}
```

### 闭包引起的内存泄漏

```javascript
var leaks = (function(){
    var leak = 'xxxxxx';// 被闭包所引用，不会被回收
    return function(){
        console.log(leak);
    }
})()
```

### dom清空或删除时，事件未清除导致的内存泄漏

```javascript
<div id="container">
</div>

$('#container').bind('click', function(){
    console.log('click');
}).remove();

// zepto 和原生 js下，#container dom 元素，还在内存里jquery 的 empty和 remove会帮助开发者避免这个问题

<div id="container">
</div>

$('#container').bind('click', function(){
    console.log('click');
}).off('click').remove();
//把事件清除了，即可从内存中移除
```
