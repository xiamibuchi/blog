# 组件

组件系统是 Vue 的一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树

## 全局组件

- 说明：全局组件在所有的 vue 实例中都可以使用
- 注意：**先注册组件，再初始化根实例**
- 注意：组件中的 `data` 必须是函数

```js
// 1 注册全局组件
Vue.component('my-component', {
  template: '<p>A custom component!</p>',
  data() {
    return {
      msg: '注意：组件的data必须是一个函数！！！'
    }
  }
})

// 2 使用：以自定义元素的方式
<div id="example">
  <my-component></my-component>
</div>

// =====> 渲染结果
<div id="example">
  <p>A custom component!</p>
</div>
```

- template 属性的值可以是：
  - 1 模板字符串
  - 2 模板 id

```html
<!-- 2 模板id 示例 -->
<script type="text/x-template" id="tpl">
  <p>A custom component!</p>
</script>

template: '#tpl'
```

- `extend`：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。

```js
// 注册组件，传入一个扩展过的构造器
Vue.component(
  "my-component",
  Vue.extend({
    /* ... */
  })
);

// 注册组件，传入一个选项对象 (自动调用 Vue.extend)
Vue.component("my-component", {
  /* ... */
});

// 内部执行过程：
var Home = Vue.extend({
  template: "",
  data() {}
});
Vue.component("home", Home);
```

## 局部组件

- 说明：局部组件，是在某一个具体的 vue 实例中定义的，只能在这个 vue 实例中使用

```js
var Child = {
  template: "<div>A custom component!</div>"
};

new Vue({
  // 注意：此处为 components
  components: {
    // <my-component> 将只在当前vue实例中使用
    "my-component": Child
  }
});
```

## 组件通讯

### 父组件到子组件

- 方式：通过`props`属性来传递数据
- 注意：属性的值必须在组件中通过`props`属性显示指定，否则，不会生效
- 说明：传递过来的`props`属性的用法与`data`属性的用法相同

```html
<hello msg="120"></hello>
<hello my-msg="'abc'"></hello>

<!-- js -->
<script>
  components: {
    hello: {
      // 显式创建props及其传递过来的属性
      props: ['msg', 'myMsg'],
      template: '<h1>这是 hello 组件，这是消息：{{msg}} --- {{myMsg}}</h1>'
    }
  }
</script>
```

### 子组件到父组件

- 方式：父组件给子组件传递一个函数，由子组件调用这个函数
- 说明：借助 vue 中的自定义事件（v-on:cunstomFn="fn"）
- `$emit()`：触发事件

```html
<hello @pfn="parentFn"></hello>

<script>
  new Vue({
    methods: {
      // 父组件：提供方法
      parentFn(data) {
        console.log("父组件：", data);
      }
    }
  });

  Vue.component("hello", {
    template: '<button @click="fn">按钮</button>',
    methods: {
      // 子组件：通过$emit调用
      fn() {
        this.$emit("pfn", "这是子组件传递给父组件的数据");
      }
    }
  });
</script>
```

### 非父子组件通讯

> 在简单的场景下，可以使用一个空的 Vue 实例作为事件总线

- `$on()`：绑定事件

```js
var bus = new Vue();

// 触发组件 A 中的事件
bus.$emit("id-selected", 1);

// 在组件 B 创建的钩子中监听事件
bus.$on("id-selected", function(id) {
  // ...
});
```

- 示例：组件 A ---> 组件 B

```html
<!-- 组件A： -->
<com-a></com-a>
<!-- 组件B： -->
<com-b></com-b>

<script>
  var bus = new Vue();

  var vm = new Vue({
    el: "#app",
    components: {
      comB: {
        template: "<p>组件A告诉我：{{msg}}</p>",
        data() {
          return {
            msg: ""
          };
        },
        created() {
          // 定义事件：
          bus.$on("tellComB", msg => {
            this.msg = msg;
          });
        }
      },

      comA: {
        template: '<button @click="emitFn">告诉B</button>',
        methods: {
          emitFn() {
            // 调用组件B中定义的事件：
            bus.$emit("tellComB", "土豆土豆我是南瓜");
          }
        }
      }
    }
  });
</script>
```

### 获取组件（或元素） - refs

- 说明：`vm.$refs` 一个对象，持有已注册过 ref 的所有子组件（或 HTML 元素）
- 使用：在 HTML 元素 中，添加`ref`属性，然后在 JS 中通过`vm.$refs.属性`来获取
- 注意：如果获取的是一个子组件，那么通过 ref 就能获取到子组件中的 data 和 methods

```html
<div ref="dv"></div>

<!-- js -->
<script>
  vm.$refs.dv;
</script>
```

## slot

使用插槽进行内容分发，来实现组件的复用：

1. 单个插槽，必须在子组件中通过 <slot></slot> 来指定分发内容展示的位置，也就是说：必须通过 slot，那么组件中的子标签才会展示出来！！！

2. 具名插槽，插槽可以有多个，通过 name 来区分不同的插槽
   2.1 在 组件的子元素中通过 slot 属性 指定插槽的名称

   `<p slot="content">这是内容</p>`

   2.2 在 组件的模板中通过 这种形式与 2.1 中的插槽名称相 对应`<slot name="content"></slot>`

## 自定义组件

全局：

```js
Vue.component("hello-component", {
  props: ["message"],
  template: "<div ><h1>组件定义之全局组件</h1><h4>{{message}}</h4></div>"
});
```

局部：

```js
const ComponentA = {
  props: ["message"],
  template:
    "<div><h1>{{message}}</h1><input  \
    type='text' v-model='message'></input></div>"
};
new Vue({
  el: "#app",
  components: {
    "component-a": ComponentA
  }
});
```

```js

makeComponent(customName, customString) {
  let codeString = this.chartInfo.customize_code_str;
  let rTemplate = /<template>(.+?)<\/template>/gi;
  let rScript = /<script>(.+?)<\/script>/gi;
  codeString = codeString.replace(/[\r\n]/g, "");
  codeString = codeString.replace("export default", "");
  let templateStr = rTemplate.exec(codeString);
  let scriptStr = rScript.exec(codeString);
  templateStr = (templateStr && templateStr[1]) || "";
  scriptStr = (scriptStr && scriptStr[1]) || "";

  eval(`scriptStr=(${scriptStr})`);
  Vue.component(customName, {
    ...scriptStr,
    template: templateStr
  });
}
```
