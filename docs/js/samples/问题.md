# 问题

## 从“在浏览器输入域名”到“页面静态资源完全加载”的整个流程

整个过程可以分为几步：

1. 用户输入

   当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 `beforeunload` 事件的机会，`beforeunload` 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面。

1. `URL` 请求过程

   首先，网络进程会查找本地缓存是否缓存了该资源。

   如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 `DNS` 解析，以获取请求域名的服务器 `IP` 地址。如果请求协议是 `HTTPS`，那么还需要建立 `TLS` 连接。

   - 其中，`DNS`也有几步缓存：浏览器缓存，`hosts`文件，
   - 如果本地域名解析服务器也没有该域名的记录，则开始递归+迭代解析
   - `TCP`三次握手，`HTTP`。`TLS`握手，`HTTPS`。

   接下来就是利用 `IP` 地址和服务器建立 `TCP` 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 `Cookie` 等数据附加到请求头中，然后向服务器发送构建的请求信息。

   数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 `HTML` 文件。

   首先浏览器会判断状态码是什么，如果是 `200` 那就继续解析，如果 `400` 或 `500` 的话就会报错，如果 `300` 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。

   浏览器开始解析文件，如果是 `gzip` 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

1. 准备渲染进程

   默认情况下，`Chrome` 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。

1. 渲染阶段

   文件解码成功后会正式开始渲染流程，先会根据 `HTML` 构建 `DOM` 树，有`CSS`的话会去构建 `CSSOM` 树。如果遇到 `script` 标签的话，会判断是否存在 `async` 或者 `defer` ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 `HTML` 解析完成后顺序执行。

   如果以上都没有，就会阻塞住渲染流程直到 `JS` 执行完毕。

   `CSSOM` 树和 `DOM` 树构建完成后会开始生成 `Render` 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西

   在生成 `Render` 树的过程中，浏览器就开始调用`GPU` 绘制，合成图层，将内容显示在屏幕上了。

## 项目优化

加载阶段：

减少关键资源的个数和大小（Webpack 拆/合包，懒加载等）
减少关键资源 RTT 的时间（Gzip 压缩，边缘节点 CDN）

交互阶段：

JS 代码不可占用主线程太久，与首屏无关的脚本加上延后处理（aysnc/defer）属性，与 DOM 无关的交给 Web Worker。
CSS 用对选择器（尽可能绑定 Class 或 Id）,否则会遍历多次。
首屏渲染中如果有动画，加上 will-change 属性，浏览器会开辟新的层处理（触发合成机制）
避免强制同步布局，避免布局抖动。
图片懒加载（有四种方式）

## 手动实现 instanceOf 机制

思路：
​ 步骤 1：先取得当前类的原型，当前实例对象的原型链
​ 步骤 2：一直循环（执行原型链的查找机制）

取得当前实例对象原型链的原型链（proto = proto.\_**\_proto\_\_**，沿着原型链一直向上查找）
如果 当前实例的原型链\_**\_proto**上找到了当前类的原型 prototype，则返回 true
如果 一直找到 Object.prototype.\_**\_proto\_\_** == null，Object 的基类(null)上面都没找到，则返回 false

```js
function _instanceof(instanceObject, classFunc) {
  let classFunc = classFunc.prototype; // 取得当前类的原型
  let proto = instanceObject.__proto__; // 取得当前实例对象的原型链

  while (true) {
    if (proto === null) {
      // 找到了 Object的基类 Object.prototype.__proto__
      return false;
    }
    if (proto === classFunc) {
      // 在当前实例对象的原型链上，找到了当前类
      return true;
    }
    proto = proto.__proto__; // 沿着原型链__ptoto__一层一层向上查找
  }
}
```

优化版 (处理兼容问题)

Object.getPrototypeOf ( )：用来获取某个实例对象的原型（内部[[prototype]]属性的值，包含 proto 属性）

```js
function _instanceof(instanceObject, classFunc) {
  let classFunc = classFunc.prototype; // 取得当前类的原型
  let proto = Object.getPrototypeOf(instanceObject); // 取得当前实例对象的原型链上的属性

  while (true) {
    if (proto === null) {
      // 找到了 Object的基类 Object.prototype.__proto__
      return false;
    }
    if (proto === classFunc) {
      // 在当前实例对象的原型链上，找到了当前类
      return true;
    }
    proto = Object.getPrototypeOf(proto); // 沿着原型链__ptoto__一层一层向上查找
  }
}
```

## debounce 防抖

```js
/**
 * 实现函数的防抖（目的是频繁触发中只执行一次）,以最后一次触发为标准
 * @param {*} func 需要执行的函数
 * @param {*} wait 检测防抖的间隔频率
 * @param {*} immediate 是否是立即执行  True：第一次，默认False：最后一次
 * @return {可被调用执行的函数}
 */
function debounce(func, wait = 500, immediate = false) {
  let timer = null;
  return (...params) => {
    if (immediate) {
      immediate = false;
      func && func(...params);
    }
    clearTimeout(timer);
    timer = setTimeout(() => {
      func && func(...params);
    }, wait);
  };
}
```

## throttle 节流

是频繁触发中缩减频率

```js
function throttle(func, wait = 500) {
  let timer = null;
  return function(...params) {
    if (!timer) {
      timer = setTimeout(function() {
        func(...params);
        clearTimeout(timer);
      }, wait);
    }
  };
}
```

## 手动实现 Object.create

```js
Object.create = function create(prototype) {
   if(prototype===null||type prototype !== "object) {
      throw new TypeError(`Object prototype may only be an Object: ${prototype}`);
   }
   function Temp() {};
   Temp.prototype = prototype;
   return new Temp;
}
```

## 手动实现 new

简化版

1. 创建一个 Func 的实例对象（实例.**proto** = 类.prototype）
2. 把 Func 当做普通函数执行，并改变 this 指向
3. 分析函数的返回值

```js
/**
 * Func: 要操作的类（最后要创建这个类的实例）
 * args：存储未来传递给Func类的实参
 */
function _new(Func, ...args) {
  // 创建一个Func的实例对象（实例.____proto____ = 类.prototype）
  let obj = {};
  obj.__proto__ = Func.prototype;
  // 或者 let obj = Object.create(Func.prototype);

  // 把Func当做普通函数执行，并改变this指向
  let result = Func.call(obj, ...args);

  // 分析函数的返回值
  if (result !== null && /^(object|function)$/.test(typeof result)) {
    return result;
  }
  return obj;
}
```

## 手动实现 call

简易版（不考虑 context 非对象情况，不考虑 Symbol\BigInt 不能 new.constructor( context )情况）

```js
/**
 * context: 要改变的函数中的this指向，写谁就是谁
 * args：传递给函数的实参信息
 * this：要处理的函数 fn
 */
Function.prototype.call = function(context, ...args) {
  //  null，undefined，和不传时，context为 window
  context = context == null ? window : context;

  let result;
  context["fn"] = this; // 把函数作为对象的某个成员值
  result = context["fn"](...args); // 把函数执行，此时函数中的this就是
  delete context["fn"]; // 设置完成员属性后，删除
  return result;
};
```

完善版（context 必须对象类型，兼容 Symbol 等情况）

```js
/**
 * context: 要改变的函数中的this指向，写谁就是谁
 * args：传递给函数的实参信息
 * this：要处理的函数 fn
 */
Function.prototype.call = function(context, ...args) {
  //  null，undefined，和不传时，context为 window
  context = context == null ? window : context;

  // 必须保证 context 是一个对象类型
  let contextType = typeof context;
  if (!/^(object|function)$/i.test(contextType)) {
    // context = new context.constructor(context); // 不适用于 Symbol/BigInt
    context = Object(context);
  }

  let result;
  context["fn"] = this; // 把函数作为对象的某个成员值
  result = context["fn"](...args); // 把函数执行，此时函数中的this就是
  delete context["fn"]; // 设置完成员属性后，删除
  return result;
};
```

## 手动实现 apply

```js
/**
 * context: 要改变的函数中的this指向，写谁就是谁
 * args：传递给函数的实参信息
 * this：要处理的函数 fn
 */
Function.prototype.apply = function(context, args) {
  context = context == null ? window : context;

  let contextType = typeof context;
  if (!/^(object|function)$/i.test(contextType)) {
    context = Object(context);
  }

  let result;
  context["fn"] = this;
  result = context["fn"](...args);
  delete context["fn"];
  return result;
};
```

## 手动实现 bind

```js
/**
 * this: 要处理的函数 func
 * context: 要改变的函数中的this指向 obj
 * params：要处理的函数传递的实参 [10, 20]
 */
Function.prototype._bind = function(context, ...params) {
  let _this = this; // this: 要处理的函数
  return function anonymous(...args) {
    // args： 可能传递的事件对象等信息 [MouseEvent]
    // this：匿名函数中的this是由当初绑定的位置 触发决定的 （总之不是要处理的函数func）
    // 所以需要_bind函数 刚进来时，保存要处理的函数 _this = this
    _this.call(context, ...params.concat(args));
  };
};
```

## 基于 Generator 函数实现 async/await 原理

> **核心：**传递给我一个`Generator`函数，把函数中的内容基于`Iterator`迭代器的特点一步步的执行

```js
function readFile(file) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(file);
    }, 1000);
  });
}

function asyncFunc(generator) {
  const iterator = generator(); // 接下来要执行next
  // data为第一次执行之后的返回结果，用于传给第二次执行
  const next = (data) => {
    let { value, done } = iterator.next(data); // 第二次执行，并接收第一次的请求结果 data

    if (done) return; // 执行完毕(到第三次)直接返回
    // 第一次执行next时，yield返回的 promise实例 赋值给了 value
    value.then((data) => {
      next(data); // 当第一次value 执行完毕且成功时，执行下一步(并把第一次的结果传递下一步)
    });
  };
  next();
}

asyncFunc(function*() {
  // 生成器函数：控制代码一步步执行
  let data = yield readFile("a.js"); // 等这一步骤执行执行成功之后，再往下走，没执行完的时候，直接返回
  data = yield readFile(data + "b.js");
  return data;
});
```

## 手动实现 sleep

某个时间过后，就去执行某个函数，基于 Promise 封装异步任务

```js
/**
 *
 * @param {*} fn 要执行的函数
 * @param {*} wait 等待的时间
 */
function sleep(wait) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve();
    }, wait);
  });
}

async function autoRun() {
  await sleep(3000);
  console.log("3000s later");
}

autoRun();
```

## ES5手动实现数组reduce
