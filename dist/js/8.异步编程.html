<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>异步编程 | 羊圈</title>
    <meta name="description" content="神羊的羊圈">
    <meta name="theme-color" content="#00adb5">
  <link rel="icon" href="/images/favicon.png">
  <meta itemprop="image" content="/js_tricks/images/favicon.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="msapplication-TileColor" content="#00adb5">
    
    <link rel="preload" href="/assets/css/0.styles.18cbf62c.css" as="style"><link rel="preload" href="/assets/js/app.c1618cf4.js" as="script"><link rel="preload" href="/assets/js/3.ed1bf183.js" as="script"><link rel="preload" href="/assets/js/74.8eed043b.js" as="script"><link rel="prefetch" href="/assets/js/1.b3385aaa.js"><link rel="prefetch" href="/assets/js/10.b526617f.js"><link rel="prefetch" href="/assets/js/100.9c76dc44.js"><link rel="prefetch" href="/assets/js/101.6b17334c.js"><link rel="prefetch" href="/assets/js/102.6072298e.js"><link rel="prefetch" href="/assets/js/103.8bf22d9c.js"><link rel="prefetch" href="/assets/js/104.da37280c.js"><link rel="prefetch" href="/assets/js/105.f6adc7cb.js"><link rel="prefetch" href="/assets/js/106.c479af52.js"><link rel="prefetch" href="/assets/js/107.7864a896.js"><link rel="prefetch" href="/assets/js/108.59251a56.js"><link rel="prefetch" href="/assets/js/109.401930b9.js"><link rel="prefetch" href="/assets/js/11.8c8a17aa.js"><link rel="prefetch" href="/assets/js/110.7f385c95.js"><link rel="prefetch" href="/assets/js/111.874ae40f.js"><link rel="prefetch" href="/assets/js/112.b88da53c.js"><link rel="prefetch" href="/assets/js/12.9a241d83.js"><link rel="prefetch" href="/assets/js/13.50f10eff.js"><link rel="prefetch" href="/assets/js/14.e6ebc69a.js"><link rel="prefetch" href="/assets/js/15.1145f768.js"><link rel="prefetch" href="/assets/js/16.8f53c91c.js"><link rel="prefetch" href="/assets/js/17.f5d33107.js"><link rel="prefetch" href="/assets/js/18.0fa172d4.js"><link rel="prefetch" href="/assets/js/19.b3ec819d.js"><link rel="prefetch" href="/assets/js/20.39dd808d.js"><link rel="prefetch" href="/assets/js/21.982519d1.js"><link rel="prefetch" href="/assets/js/22.e43852de.js"><link rel="prefetch" href="/assets/js/23.d20b98a1.js"><link rel="prefetch" href="/assets/js/24.8df2408b.js"><link rel="prefetch" href="/assets/js/25.6b7a2412.js"><link rel="prefetch" href="/assets/js/26.e0d54718.js"><link rel="prefetch" href="/assets/js/27.fa540f01.js"><link rel="prefetch" href="/assets/js/28.12872a08.js"><link rel="prefetch" href="/assets/js/29.a5357381.js"><link rel="prefetch" href="/assets/js/30.877d7c50.js"><link rel="prefetch" href="/assets/js/31.b4278efa.js"><link rel="prefetch" href="/assets/js/32.ebc68bbd.js"><link rel="prefetch" href="/assets/js/33.f08d05c9.js"><link rel="prefetch" href="/assets/js/34.a7d62a8e.js"><link rel="prefetch" href="/assets/js/35.f5d32a01.js"><link rel="prefetch" href="/assets/js/36.1ba48a2d.js"><link rel="prefetch" href="/assets/js/37.3e7062af.js"><link rel="prefetch" href="/assets/js/38.46a40d24.js"><link rel="prefetch" href="/assets/js/39.f11b85d4.js"><link rel="prefetch" href="/assets/js/4.1b01fc51.js"><link rel="prefetch" href="/assets/js/40.28ecd869.js"><link rel="prefetch" href="/assets/js/41.5e8bc3d9.js"><link rel="prefetch" href="/assets/js/42.ff6b4e3c.js"><link rel="prefetch" href="/assets/js/43.9a77ccd5.js"><link rel="prefetch" href="/assets/js/44.b54ec253.js"><link rel="prefetch" href="/assets/js/45.cbee26e2.js"><link rel="prefetch" href="/assets/js/46.5e19d09a.js"><link rel="prefetch" href="/assets/js/47.0acc679f.js"><link rel="prefetch" href="/assets/js/48.bfdd685b.js"><link rel="prefetch" href="/assets/js/49.e42f572c.js"><link rel="prefetch" href="/assets/js/5.d587daef.js"><link rel="prefetch" href="/assets/js/50.85bfbfcd.js"><link rel="prefetch" href="/assets/js/51.576a7373.js"><link rel="prefetch" href="/assets/js/52.f26ffee5.js"><link rel="prefetch" href="/assets/js/53.163cf701.js"><link rel="prefetch" href="/assets/js/54.c1132ecc.js"><link rel="prefetch" href="/assets/js/55.e089f0d4.js"><link rel="prefetch" href="/assets/js/56.be59a8ef.js"><link rel="prefetch" href="/assets/js/57.a015f201.js"><link rel="prefetch" href="/assets/js/58.0235e47f.js"><link rel="prefetch" href="/assets/js/59.0b6f5acf.js"><link rel="prefetch" href="/assets/js/6.69e07e2c.js"><link rel="prefetch" href="/assets/js/60.641c2f95.js"><link rel="prefetch" href="/assets/js/61.17b03fa8.js"><link rel="prefetch" href="/assets/js/62.96134956.js"><link rel="prefetch" href="/assets/js/63.f845d120.js"><link rel="prefetch" href="/assets/js/64.e9ed93d9.js"><link rel="prefetch" href="/assets/js/65.2bd53147.js"><link rel="prefetch" href="/assets/js/66.1f03bf79.js"><link rel="prefetch" href="/assets/js/67.47eb30d1.js"><link rel="prefetch" href="/assets/js/68.cc339c5a.js"><link rel="prefetch" href="/assets/js/69.2ff09789.js"><link rel="prefetch" href="/assets/js/7.3199f861.js"><link rel="prefetch" href="/assets/js/70.9d03d949.js"><link rel="prefetch" href="/assets/js/71.7eab78cd.js"><link rel="prefetch" href="/assets/js/72.20dd5f6e.js"><link rel="prefetch" href="/assets/js/73.6c6af6b0.js"><link rel="prefetch" href="/assets/js/75.3b5158cd.js"><link rel="prefetch" href="/assets/js/76.0eacd2d9.js"><link rel="prefetch" href="/assets/js/77.c3ba3709.js"><link rel="prefetch" href="/assets/js/78.843656e9.js"><link rel="prefetch" href="/assets/js/79.99bae0b9.js"><link rel="prefetch" href="/assets/js/8.8d4fcdde.js"><link rel="prefetch" href="/assets/js/80.4d3c67b0.js"><link rel="prefetch" href="/assets/js/81.85eaf0e7.js"><link rel="prefetch" href="/assets/js/82.27feb7aa.js"><link rel="prefetch" href="/assets/js/83.7686c618.js"><link rel="prefetch" href="/assets/js/84.941fa5d5.js"><link rel="prefetch" href="/assets/js/85.46a4182a.js"><link rel="prefetch" href="/assets/js/86.1d2fa06f.js"><link rel="prefetch" href="/assets/js/87.1fa71add.js"><link rel="prefetch" href="/assets/js/88.a9a069f0.js"><link rel="prefetch" href="/assets/js/89.93d73858.js"><link rel="prefetch" href="/assets/js/9.99351bd6.js"><link rel="prefetch" href="/assets/js/90.029a12be.js"><link rel="prefetch" href="/assets/js/91.669f4475.js"><link rel="prefetch" href="/assets/js/92.686c84ef.js"><link rel="prefetch" href="/assets/js/93.47bd8585.js"><link rel="prefetch" href="/assets/js/94.0b908759.js"><link rel="prefetch" href="/assets/js/95.f4d85cb9.js"><link rel="prefetch" href="/assets/js/96.e57f6246.js"><link rel="prefetch" href="/assets/js/97.b5660771.js"><link rel="prefetch" href="/assets/js/98.91198c9e.js"><link rel="prefetch" href="/assets/js/99.9a6c1efc.js">
    <link rel="stylesheet" href="/assets/css/0.styles.18cbf62c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">羊圈</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">blog</a></div><div class="nav-item"><a href="https://qishaoxuan.github.io/animate_resume/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  about me
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">blog</a></div><div class="nav-item"><a href="https://qishaoxuan.github.io/animate_resume/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  about me
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/1.基础知识.html" class="sidebar-link">基础知识</a></li><li><a href="/js/2.数据类型.html" class="sidebar-link">数据类型</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="异步编程">异步编程</h1> <p>常见异步编程方案</p> <ul><li>回调函数</li> <li>事件监听</li> <li>发布/订阅</li> <li>Promise 对象</li></ul> <h2 id="事件循环">事件循环</h2> <p>Event Loop。</p> <p>JavaScript 的一大特点就是单线程，而这个线程中拥有唯一的一个事件循环，JavaScript 代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来执行另外一些代码的执行。</p> <ul><li>一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。</li> <li>任务队列又分为 macro-task（宏任务）与 micro-task（微任务），在最新标准中，它们被分别称为 task 与 jobs。</li> <li>macro-task 大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。</li> <li>micro-task 大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5 新特性)
setTimeout/Promise 等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。</li> <li>来自不同任务源的任务会进入到不同的任务队列。其中 setTimeout 与 setInterval 是同源的。</li> <li>事件循环的顺序，决定了 JavaScript 代码的执行顺序。它从 script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的 micro-task。当所有可执行的 micro-task 执行完毕之后。循环再次从 macro-task 开始，找到其中一个任务队列执行完毕，然后再执行所有的 micro-task，这样一直循环下去。</li> <li>其中每一个任务的执行，无论是 macro-task 还是 micro-task，都是借助函数调用栈来完成。</li></ul> <h2 id="回调函数">回调函数</h2> <p>对于回调函数 我们用 Jquery 的 ajax 获取数据时 都是以回调函数方式获取的数据</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>$<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre></div><p>当我们需要发送多个异步请求 并且每个请求之间需要相互依赖 那这时 我们只能以嵌套方式来解决，形成 &quot;回调地狱&quot;</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>$<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token parameter">data1</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data1<span class="token punctuation">)</span>
    $<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>data1<span class="token punctuation">.</span>url<span class="token punctuation">,</span> <span class="token parameter">data2</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data1<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>这样一来，在处理越多的异步逻辑时，就需要越深的回调嵌套，这种编码模式的问题主要有以下几个：</p></blockquote> <ul><li>代码逻辑书写顺序与执行顺序不一致，不利于阅读与维护。</li> <li>异步操作的顺序变更时，需要大规模的代码重构。</li> <li>回调函数基本都是匿名函数，bug 追踪困难。</li> <li>回调函数是被第三方库代码（如上例中的 ajax ）而非自己的业务代码所调用的，造成了 IoC 控制反转。</li></ul> <h2 id="promise">promise</h2> <p>Promise 是异步编程的一种解决方案，比传统的解决方案回调函数更合理和更强大。</p> <p>语法上说，Promise 是一个对象，表示一个异步操作最终的结果。</p> <p>Promise 对象状态不受外界影响，有三种状态：</p> <ul><li>pending（进行中）</li> <li>fulfilled（已成功）</li> <li>rejected（已失败）</li></ul> <p>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。</p> <h3 id="处理多个相互关联的异步请求">处理多个相互关联的异步请求</h3> <p>Promise 可以更直观的方式 来解决 &quot;回调地狱&quot;</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">request</span> <span class="token operator">=</span> <span class="token parameter">url</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        $<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 请求data1</span>
<span class="token function">request</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data1</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">request</span><span class="token punctuation">(</span>data1<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data2</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">request</span><span class="token punctuation">(</span>data2<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data3</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="简介">简介</h3> <p>Promise 是一个构造函数， new Promise 返回一个 promise 对象 接收一个 excutor 执行函数作为参数, excutor 有两个函数类型形参 resolve reject</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 异步处理</span>
    <span class="token comment">// 处理结束后、调用resolve 或 reject</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>promise 相当于一个状态机</p> <p>promise 的三种状态</p> <ul><li>pending</li> <li>fulfilled</li> <li>rejected</li></ul> <ol><li>promise 对象初始化状态为 pending</li> <li>当调用 resolve(成功)，会由 pending =&gt; fulfilled</li> <li>当调用 reject(失败)，会由 pending =&gt; rejected</li></ol> <blockquote><p>注意 promsie 状态 只能由 pending =&gt; fulfilled/rejected, 一旦修改就不能再变</p></blockquote> <h3 id="方法">方法</h3> <ol><li><p>then 方法注册 当 resolve(成功)/reject(失败)的回调函数</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token comment">// onFulfilled 是用来接收promise成功的值</span>
<span class="token comment">// onRejected 是用来接收promise失败的原因</span>
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>then 方法是异步执行的</p></blockquote></li> <li><p>resolve(成功) onFulfilled 会被调用</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
<span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'fulfilled'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 状态由 pending =&gt; fulfilled</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// onFulfilled</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'fulfilled'</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// onRejected 不会被调用</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>reject(失败) onRejected 会被调用</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
<span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'rejected'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 状态由 pending =&gt; rejected</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// onFulfilled 不会被调用</span>

<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// onRejected</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rejected<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'rejected'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>promise.catch</p> <blockquote><p>在链式写法中可以捕获前面 then 中发送的异常</p></blockquote> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>promise<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span>
相当于
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> onRrejected<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 注意</span>
<span class="token comment">// onRejected 不能捕获当前onFulfilled中的异常</span>
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span> onRrejected<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 可以写成：</span>
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>onRrejected<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>promise chain</p> <blockquote><p>promise.then 方法每次调用 都返回一个新的 promise 对象 所以可以链式写法</p></blockquote> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">taskA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Task A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">taskB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Task B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Catch Error: A or B&quot;</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> promise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
promise
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>taskA<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>taskB<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span> <span class="token comment">// 捕获前面then方法中的异常</span>
</code></pre></div></li> <li><p>Promise 的静态方法</p></li></ol> <p>1.Promise.resolve 返回一个 fulfilled 状态的 promise 对象</p> <div class="language- extra-class"><pre class="language-text"><code>Promise.resolve('hello').then(function(value){
    console.log(value);
});

Promise.resolve('hello');
// 相当于
const promise = new Promise(resolve =&gt; {
   resolve('hello');
});
</code></pre></div><p>2.Promise.reject 返回一个 rejected 状态的 promise 对象</p> <div class="language- extra-class"><pre class="language-text"><code>Promise.reject(24);
new Promise((resolve, reject) =&gt; {
   reject(24);
});
</code></pre></div><p>3.Promise.all 接收一个 promise 对象数组为参数</p> <blockquote><p>只有全部为 resolve 才会调用 通常会用来处理 多个并行异步操作</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>const p1 = new Promise((resolve, reject) =&gt; {
    resolve(1);
});

const p2 = new Promise((resolve, reject) =&gt; {
    resolve(2);
});

const p3 = new Promise((resolve, reject) =&gt; {
    reject(3);
});

Promise.all([p1, p2, p3]).then(data =&gt; {
    console.log(data); // [1, 2, 3] 结果顺序和promise实例数组顺序是一致的
}, err =&gt; {
    console.log(err);
});
</code></pre></div><p>4.Promise.race 接收一个 promise 对象数组为参数</p> <blockquote><p>Promise.race 只要有一个 promise 对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>function timerPromisefy(delay) {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            resolve(delay);
        }, delay);
    });
}
var startDate = Date.now();

Promise.race([
    timerPromisefy(10),
    timerPromisefy(20),
    timerPromisefy(30)
]).then(function (values) {
    console.log(values); // 10
});
</code></pre></div><h3 id="promise-代码实现">Promise 代码实现</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
 * Promise 实现 遵循promise/A+规范
 * Promise/A+规范译文:
 * https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/#note-4
 */</span>

<span class="token comment">// promise 三个状态</span>
<span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">&quot;pending&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">FULFILLED</span> <span class="token operator">=</span> <span class="token string">&quot;fulfilled&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">&quot;rejected&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Promise</span><span class="token punctuation">(</span><span class="token parameter">excutor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 缓存当前promise实例对象</span>
  that<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">PENDING</span><span class="token punctuation">;</span> <span class="token comment">// 初始状态</span>
  that<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// fulfilled状态时 返回的信息</span>
  that<span class="token punctuation">.</span>reason <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// rejected状态时 拒绝的原因</span>
  that<span class="token punctuation">.</span>onFulfilledCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储fulfilled状态对应的onFulfilled函数</span>
  that<span class="token punctuation">.</span>onRejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储rejected状态对应的onRejected函数</span>

  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// value成功态时接收的终值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 为什么resolve 加setTimeout?</span>
    <span class="token comment">// 2.2.4规范 onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行.</span>
    <span class="token comment">// 注1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</span>

    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 调用resolve 回调对应onFulfilled函数</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>that<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 只能由pedning状态 =&gt; fulfilled状态 (避免调用多次resolve reject)</span>
        that<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">FULFILLED</span><span class="token punctuation">;</span>
        that<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
        that<span class="token punctuation">.</span>onFulfilledCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">cb</span> <span class="token operator">=&gt;</span> <span class="token function">cb</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// reason失败态时接收的拒因</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 调用reject 回调对应onRejected函数</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>that<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 只能由pedning状态 =&gt; rejected状态 (避免调用多次resolve reject)</span>
        that<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">REJECTED</span><span class="token punctuation">;</span>
        that<span class="token punctuation">.</span>reason <span class="token operator">=</span> reason<span class="token punctuation">;</span>
        that<span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">cb</span> <span class="token operator">=&gt;</span> <span class="token function">cb</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 捕获在excutor执行器中抛出的异常</span>
  <span class="token comment">// new Promise((resolve, reject) =&gt; {</span>
  <span class="token comment">//     throw new Error('error in excutor')</span>
  <span class="token comment">// })</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token function">excutor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * resolve中的值几种情况：
 * 1.普通值
 * 2.promise对象
 * 3.thenable对象/函数
 */</span>

<span class="token comment">/**
 * 对resolve 进行改造增强 针对resolve中不同值情况 进行处理
 * @param  {promise} promise2 promise1.then方法返回的新的promise对象
 * @param  {[type]} x         promise1中onFulfilled的返回值
 * @param  {[type]} resolve   promise2的resolve方法
 * @param  {[type]} reject    promise2的reject方法
 */</span>
<span class="token keyword">function</span> <span class="token function">resolvePromise</span><span class="token punctuation">(</span><span class="token parameter">promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>promise2 <span class="token operator">===</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果从onFulfilled中返回的x 就是promise2 就会导致循环引用报错</span>
    <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;循环引用&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> called <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 避免多次调用</span>
  <span class="token comment">// 如果x是一个promise对象 （该判断和下面 判断是不是thenable对象重复 所以可有可无）</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获得它的终值 继续resolve</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果为等待态需等待直至 x 被执行或拒绝 并解析y值</span>
      x<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
        <span class="token parameter">y</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> y<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果 x 已经处于执行态/拒绝态(值已经被解析为普通值)，用相同的值执行传递下去 promise</span>
      x<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果 x 为对象或者函数</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">// 是否是thenable对象（具有then方法的对象/函数）</span>
      <span class="token keyword">let</span> then <span class="token operator">=</span> x<span class="token punctuation">.</span>then<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> then <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">then</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>
          x<span class="token punctuation">,</span>
          <span class="token parameter">y</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
            called <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> y<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
            called <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 说明是一个普通对象/函数</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
      called <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * [注册fulfilled状态/rejected状态对应的回调函数]
 * @param  {function} onFulfilled fulfilled状态时 执行的函数
 * @param  {function} onRejected  rejected状态时 执行的函数
 * @return {function} newPromsie  返回一个新的promise对象
 */</span>
<span class="token class-name">Promise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">onFulfilled<span class="token punctuation">,</span> onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> newPromise<span class="token punctuation">;</span>
  <span class="token comment">// 处理参数默认值 保证参数后续能够继续执行</span>
  onFulfilled <span class="token operator">=</span>
    <span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span> <span class="token operator">?</span> <span class="token function-variable function">onFulfilled</span> <span class="token punctuation">:</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> value<span class="token punctuation">;</span>
  onRejected <span class="token operator">=</span>
    <span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span>
      <span class="token operator">?</span> <span class="token function-variable function">onRejected</span>
      <span class="token punctuation">:</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token keyword">throw</span> reason<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// then里面的FULFILLED/REJECTED状态时 为什么要加setTimeout ?</span>
  <span class="token comment">// 原因:</span>
  <span class="token comment">// 其一 2.2.4规范 要确保 onFulfilled 和 onRejected 方法异步执行(且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行) 所以要在resolve里加上setTimeout</span>
  <span class="token comment">// 其二 2.2.6规范 对于一个promise，它的then方法可以调用多次.（当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED/REJECTED状态，则会走的下面逻辑),所以要确保为FULFILLED/REJECTED状态后 也要异步执行onFulfilled/onRejected</span>

  <span class="token comment">// 其二 2.2.6规范 也是resolve函数里加setTimeout的原因</span>
  <span class="token comment">// 总之都是 让then方法异步执行 也就是确保onFulfilled/onRejected异步执行</span>

  <span class="token comment">// 如下面这种情景 多次调用p1.then</span>
  <span class="token comment">// p1.then((value) =&gt; { // 此时p1.status 由pedding状态 =&gt; fulfilled状态</span>
  <span class="token comment">//     console.log(value); // resolve</span>
  <span class="token comment">//     // console.log(p1.status); // fulfilled</span>
  <span class="token comment">//     p1.then(value =&gt; { // 再次p1.then 这时已经为fulfilled状态 走的是fulfilled状态判断里的逻辑 所以我们也要确保判断里面onFuilled异步执行</span>
  <span class="token comment">//         console.log(value); // 'resolve'</span>
  <span class="token comment">//     });</span>
  <span class="token comment">//     console.log('当前执行栈中同步代码');</span>
  <span class="token comment">// })</span>
  <span class="token comment">// console.log('全局执行栈中同步代码');</span>
  <span class="token comment">//</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>that<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 成功态</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>newPromise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">resolvePromise</span><span class="token punctuation">(</span>newPromise<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 新的promise resolve 上一个onFulfilled的返回值</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>that<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 失败态</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>newPromise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">resolvePromise</span><span class="token punctuation">(</span>newPromise<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>that<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 等待态</span>
    <span class="token comment">// 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>newPromise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      that<span class="token punctuation">.</span>onFulfilledCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">resolvePromise</span><span class="token punctuation">(</span>newPromise<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      that<span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">resolvePromise</span><span class="token punctuation">(</span>newPromise<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Promise.all Promise进行并行处理
 * 参数: promise对象组成的数组作为参数
 * 返回值: 返回一个Promise实例
 * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。
 */</span>
Promise<span class="token punctuation">.</span><span class="token function-variable function">all</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">promises</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> done <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span>promises<span class="token punctuation">.</span>length<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span><span class="token punctuation">;</span>
    promises<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">promise<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">done</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token parameter">length<span class="token punctuation">,</span> resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>count <span class="token operator">===</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * Promise.race
 * 参数: 接收 promise对象组成的数组作为参数
 * 返回值: 返回一个Promise实例
 * 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理(取决于哪一个更快)
 */</span>
Promise<span class="token punctuation">.</span><span class="token function-variable function">race</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">promises</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    promises<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">promise<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 用于promise方法链时 捕获前面onFulfilled/onRejected抛出的异常</span>
<span class="token class-name">Promise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">catch</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function-variable function">reject</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 基于Promise实现Deferred的
 * Deferred和Promise的关系
 * - Deferred 拥有 Promise
 * - Deferred 具备对 Promise的状态进行操作的特权方法（resolve reject）
 *
 *参考jQuery.Deferred
 *url: http://api.jquery.com/category/deferred-object/
 */</span>
Promise<span class="token punctuation">.</span><span class="token function-variable function">deferred</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 延迟对象</span>
  <span class="token keyword">let</span> defer <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  defer<span class="token punctuation">.</span>promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    defer<span class="token punctuation">.</span>resolve <span class="token operator">=</span> resolve<span class="token punctuation">;</span>
    defer<span class="token punctuation">.</span>reject <span class="token operator">=</span> reject<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> defer<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Promise/A+规范测试
 * npm i -g promises-aplus-tests
 * promises-aplus-tests Promise.js
 */</span>

<span class="token keyword">try</span> <span class="token punctuation">{</span>
  module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Promise<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><h2 id="async-await">async/await</h2> <p>随着 <a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer">Node 7<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的发布，越来越多的人开始研究据说是异步编程终级解决方案的 async/await。我第一次看到这组关键字并不是在 JavaScript 语言里，而是在 c# 5.0 的语法中。C# 的 async/await 需要在 .NET Framework 4.5 以上的版本中使用，因此我还很悲伤了一阵——为了要兼容 XP 系统，我们开发的软件不能使用高于 4.0 版本的 .NET Framework。</p> <p>我之前在<a href="https://segmentfault.com/a/1190000003742890" target="_blank" rel="noopener noreferrer">《闲谈异步调用“扁平”化》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中就谈到了这个问题。无论是在 C# 还是 JavaScript 中，async/await 都是非常棒的特性，它们也都是非常甜的语法糖。C# 的 async/await 实现离不开 <a href="https://msdn.microsoft.com/library/dd321424.aspx" target="_blank" rel="noopener noreferrer">Task 或 Task<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 类，而 JavaScript 的 async/await 实现，也离不开 <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer">Promise<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>现在抛开 C# 和 .NET Framework，专心研究下 JavaScript 的 async/await。</p> <h2 id="async-和-await-在干什么">async 和 await 在干什么</h2> <p>任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p> <p>另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？</p> <p>如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日……</p> <p>如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？</p> <h3 id="async-起什么作用">async 起什么作用</h3> <p>这个问题的关键在于，async 函数是怎么处理它的返回值的！</p> <p>我们当然希望它能直接通过 <code>return</code> 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么：</p> <div class="language- extra-class"><pre class="language-text"><code>async function testAsync() {
    return &quot;hello async&quot;;
}

const result = testAsync();
console.log(result);
</code></pre></div><p>看到输出就恍然大悟了——输出的是一个 Promise 对象。</p> <div class="language- extra-class"><pre class="language-text"><code>c:\var\test&gt; node --harmony_async_await .
Promise { 'hello async' }
</code></pre></div><p>所以，async 函数返回的是一个 Promise 对象。从<a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener noreferrer">文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p> <p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样</p> <div class="language- extra-class"><pre class="language-text"><code>testAsync().then(v =&gt; {
    console.log(v);    // 输出 hello async
});
</code></pre></div><p>现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p> <p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p> <p>那么下一个关键点就在于 await 关键字了。</p> <h3 id="await-到底在等啥">await 到底在等啥</h3> <p>一般来说，都认为 await 是在等待一个 async 函数完成。不过按<a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener noreferrer">语法说明<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p> <p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行</p> <div class="language- extra-class"><pre class="language-text"><code>function getSomething() {
    return &quot;something&quot;;
}

async function testAsync() {
    return Promise.resolve(&quot;hello async&quot;);
}

async function test() {
    const v1 = await getSomething();
    const v2 = await testAsync();
    console.log(v1, v2);
}

test();
</code></pre></div><h3 id="await-等到了要等的，然后呢">await 等到了要等的，然后呢</h3> <p>await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，<code>await</code> 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。</p> <p>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</p> <p>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</p> <blockquote><p>看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</p></blockquote> <h2 id="async-await-帮我们干了啥">async/await 帮我们干了啥</h2> <h3 id="作个简单的比较">作个简单的比较</h3> <p>上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。</p> <p>现在举例，用 <code>setTimeout</code> 模拟耗时的异步操作，先来看看不用 async/await 会怎么写</p> <div class="language- extra-class"><pre class="language-text"><code>function takeLongTime() {
    return new Promise(resolve =&gt; {
        setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000);
    });
}

takeLongTime().then(v =&gt; {
    console.log(&quot;got&quot;, v);
});
</code></pre></div><p>如果改用 async/await 呢，会是这样</p> <div class="language- extra-class"><pre class="language-text"><code>function takeLongTime() {
    return new Promise(resolve =&gt; {
        setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000);
    });
}

async function test() {
    const v = await takeLongTime();
    console.log(v);
}

test();
</code></pre></div><p>眼尖的同学已经发现 <code>takeLongTime()</code> 没有申明为 <code>async</code>。实际上，<code>takeLongTime()</code> 本身就是返回的 Promise 对象，加不加 <code>async</code> 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。</p> <p>又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async/await 还需要多写一些代码，那它的优势到底在哪？</p> <h3 id="async-await-的优势在于处理-then-链">async/await 的优势在于处理 then 链</h3> <p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p> <p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 <code>setTimeout</code> 来模拟异步操作：</p> <div class="language- extra-class"><pre class="language-text"><code>/**
 * 传入参数 n，表示这个函数执行的时间（毫秒）
 * 执行的结果是 n + 200，这个值将用于下一步骤
 */
function takeLongTime(n) {
    return new Promise(resolve =&gt; {
        setTimeout(() =&gt; resolve(n + 200), n);
    });
}

function step1(n) {
    console.log(`step1 with ${n}`);
    return takeLongTime(n);
}

function step2(n) {
    console.log(`step2 with ${n}`);
    return takeLongTime(n);
}

function step3(n) {
    console.log(`step3 with ${n}`);
    return takeLongTime(n);
}
</code></pre></div><p>现在用 Promise 方式来实现这三个步骤的处理</p> <div class="language- extra-class"><pre class="language-text"><code>function doIt() {
    console.time(&quot;doIt&quot;);
    const time1 = 300;
    step1(time1)
        .then(time2 =&gt; step2(time2))
        .then(time3 =&gt; step3(time3))
        .then(result =&gt; {
            console.log(`result is ${result}`);
            console.timeEnd(&quot;doIt&quot;);
        });
}

doIt();

// c:\var\test&gt;node --harmony_async_await .
// step1 with 300
// step2 with 500
// step3 with 700
// result is 900
// doIt: 1507.251ms
</code></pre></div><p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> = <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p> <p>如果用 async/await 来实现呢，会是这样</p> <div class="language- extra-class"><pre class="language-text"><code>async function doIt() {
    console.time(&quot;doIt&quot;);
    const time1 = 300;
    const time2 = await step1(time1);
    const time3 = await step2(time2);
    const result = await step3(time3);
    console.log(`result is ${result}`);
    console.timeEnd(&quot;doIt&quot;);
}

doIt();
</code></pre></div><p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p> <h3 id="还有更酷的">还有更酷的</h3> <p>现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。</p> <div class="language- extra-class"><pre class="language-text"><code>function step1(n) {
    console.log(`step1 with ${n}`);
    return takeLongTime(n);
}

function step2(m, n) {
    console.log(`step2 with ${m} and ${n}`);
    return takeLongTime(m + n);
}

function step3(k, m, n) {
    console.log(`step3 with ${k}, ${m} and ${n}`);
    return takeLongTime(k + m + n);
}
</code></pre></div><p>这回先用 async/await 来写：</p> <div class="language- extra-class"><pre class="language-text"><code>async function doIt() {
    console.time(&quot;doIt&quot;);
    const time1 = 300;
    const time2 = await step1(time1);
    const time3 = await step2(time1, time2);
    const result = await step3(time1, time2, time3);
    console.log(`result is ${result}`);
    console.timeEnd(&quot;doIt&quot;);
}

doIt();

// c:\var\test&gt;node --harmony_async_await .
// step1 with 300
// step2 with 800 = 300 + 500
// step3 with 1800 = 300 + 500 + 1000
// result is 2000
// doIt: 2907.387ms
</code></pre></div><p>除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？</p> <div class="language- extra-class"><pre class="language-text"><code>function doIt() {
    console.time(&quot;doIt&quot;);
    const time1 = 300;
    step1(time1)
        .then(time2 =&gt; {
            return step2(time1, time2)
                .then(time3 =&gt; [time1, time2, time3]);
        })
        .then(times =&gt; {
            const [time1, time2, time3] = times;
            return step3(time1, time2, time3);
        })
        .then(result =&gt; {
            console.log(`result is ${result}`);
            console.timeEnd(&quot;doIt&quot;);
        });
}

doIt();
</code></pre></div><p>有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— 参数传递太麻烦了，看着就晕！</p> <h2 id="洗洗睡吧">洗洗睡吧</h2> <p>就目前来说，已经理解 async/await 了吧？但其实还有一些事情没提及——Promise 有可能 reject 啊，怎么处理呢？如果需要并行处理 3 个步骤，再等待所有结果，又该怎么处理呢？</p> <p><a href="http://www.ruanyifeng.com/blog/2015/05/async.html" target="_blank" rel="noopener noreferrer">阮一峰老师已经说过了<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，我就懒得说了。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><div class="cat-container" data-v-a13867c0><canvas id="vuepress-cat" width="280" height="250" class="live2d" data-v-a13867c0></canvas></div></div></div>
    <script src="/assets/js/app.c1618cf4.js" defer></script><script src="/assets/js/3.ed1bf183.js" defer></script><script src="/assets/js/74.8eed043b.js" defer></script>
  </body>
</html>
